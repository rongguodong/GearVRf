<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_45) on Tue Jun 02 14:07:05 PDT 2015 -->
<title>GVRContext</title>
<meta name="date" content="2015-06-02">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="GVRContext";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":9,"i1":6,"i2":6,"i3":6,"i4":6,"i5":10,"i6":10,"i7":10,"i8":10,"i9":6,"i10":6,"i11":10,"i12":10,"i13":6,"i14":10,"i15":10,"i16":6,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10,"i32":10,"i33":10,"i34":10,"i35":10,"i36":42,"i37":6,"i38":6,"i39":6,"i40":6};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],8:["t4","Concrete Methods"],32:["t6","Deprecated Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/GVRContext.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-files/index-1.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../org/gearvrf/GVRCameraRig.GVRCameraRigType.YawOnly.html" title="class in org.gearvrf"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../org/gearvrf/GVRCubemapTexture.html" title="class in org.gearvrf"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?org/gearvrf/GVRContext.html" target="_top">Frames</a></li>
<li><a href="GVRContext.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.gearvrf</div>
<h2 title="Class GVRContext" class="title">Class GVRContext</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>org.gearvrf.GVRContext</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public abstract class <span class="typeNameLabel">GVRContext</span>
extends java.lang.Object</pre>
<div class="block">Like the Android <code>Context</code> class, <code>GVRContext</code> provides core
 services, and global information about an application environment.
 
 Use <code>GVRContext</code> to <a href="../../org/gearvrf/GVRContext.html#createQuad-float-float-">create</a> and
 <a href="../../org/gearvrf/GVRContext.html#loadMesh-org.gearvrf.GVRAndroidResource-">load</a> GL meshes, Android
 <a href="../../org/gearvrf/GVRContext.html#loadBitmap-java.lang.String-">bitmaps</a>, and
 <a href="../../org/gearvrf/GVRContext.html#loadTexture-org.gearvrf.GVRAndroidResource-">GL textures.</a> <code>GVRContext</code>
 also holds the <a href="../../org/gearvrf/GVRScene.html" title="class in org.gearvrf">main scene</a> and miscellaneous information
 like <a href="../../org/gearvrf/GVRContext.html#getFrameTime--">the frame time.</a></div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#DEFAULT_PRIORITY">DEFAULT_PRIORITY</a></span></code>
<div class="block">The priority used by
 <a href="../../org/gearvrf/GVRContext.html#loadBitmapTexture-org.gearvrf.GVRAndroidResource.BitmapTextureCallback-org.gearvrf.GVRAndroidResource-"><code>loadBitmapTexture(GVRAndroidResource.BitmapTextureCallback, GVRAndroidResource)</code></a>
 and
 <a href="../../org/gearvrf/GVRContext.html#loadMesh-org.gearvrf.GVRAndroidResource.MeshCallback-org.gearvrf.GVRAndroidResource-"><code>loadMesh(GVRAndroidResource.MeshCallback, GVRAndroidResource)</code></a></div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#HIGHEST_PRIORITY">HIGHEST_PRIORITY</a></span></code>
<div class="block">GVRF can't use every <code>int</code> as a priority - it needs some sentinel
 values.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#LOWEST_PRIORITY">LOWEST_PRIORITY</a></span></code>
<div class="block">GVRF can't use every <code>int</code> as a priority - it needs some sentinel
 values.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#RESERVED_PRIORITIES">RESERVED_PRIORITIES</a></span></code>
<div class="block">GVRF can't use every <code>int</code> as a priority - it needs some sentinel
 values.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t6" class="tableTab"><span><a href="javascript:show(32);">Deprecated Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#addResetOnRestartHandler-java.lang.Runnable-">addResetOnRestartHandler</a></span>(java.lang.Runnable&nbsp;handler)</code>
<div class="block">Register a method that is called every time GVRF creates a new
 <a href="../../org/gearvrf/GVRContext.html" title="class in org.gearvrf"><code>GVRContext</code></a>.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#captureScreen3D-org.gearvrf.GVRScreenshot3DCallback-">captureScreen3D</a></span>(<a href="../../org/gearvrf/GVRScreenshot3DCallback.html" title="interface in org.gearvrf">GVRScreenshot3DCallback</a>&nbsp;callback)</code>
<div class="block">Capture a 3D screenshot from the position of left eye.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#captureScreenCenter-org.gearvrf.GVRScreenshotCallback-">captureScreenCenter</a></span>(<a href="../../org/gearvrf/GVRScreenshotCallback.html" title="interface in org.gearvrf">GVRScreenshotCallback</a>&nbsp;callback)</code>
<div class="block">Capture a 2D screenshot from the position in the middle of left eye and
 right eye.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#captureScreenLeft-org.gearvrf.GVRScreenshotCallback-">captureScreenLeft</a></span>(<a href="../../org/gearvrf/GVRScreenshotCallback.html" title="interface in org.gearvrf">GVRScreenshotCallback</a>&nbsp;callback)</code>
<div class="block">Capture a 2D screenshot from the position of left eye.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#captureScreenRight-org.gearvrf.GVRScreenshotCallback-">captureScreenRight</a></span>(<a href="../../org/gearvrf/GVRScreenshotCallback.html" title="interface in org.gearvrf">GVRScreenshotCallback</a>&nbsp;callback)</code>
<div class="block">Capture a 2D screenshot from the position of right eye.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code><a href="../../org/gearvrf/GVRMesh.html" title="class in org.gearvrf">GVRMesh</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#createQuad-float-float-">createQuad</a></span>(float&nbsp;width,
          float&nbsp;height)</code>
<div class="block">Creates a quad consisting of two triangles, with the specified width and
 height.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code><a href="../../org/gearvrf/GVRActivity.html" title="class in org.gearvrf">GVRActivity</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#getActivity--">getActivity</a></span>()</code>
<div class="block">Get the Android <code>Activity</code> which launched your GVRF app.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code><a href="../../org/gearvrf/animation/GVRAnimationEngine.html" title="class in org.gearvrf.animation">GVRAnimationEngine</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#getAnimationEngine--">getAnimationEngine</a></span>()</code>
<div class="block">The <a href="../../org/gearvrf/animation/GVRAnimationEngine.html" title="class in org.gearvrf.animation">animation engine</a> singleton.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>Context</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#getContext--">getContext</a></span>()</code>
<div class="block">Get the Android <code>Context</code>, which provides access to system services
 and to your application's resources.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>abstract float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#getFrameTime--">getFrameTime</a></span>()</code>
<div class="block">The interval between this frame and the previous frame, in seconds: a
 rough gauge of Frames Per Second.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>abstract <a href="../../org/gearvrf/GVRScene.html" title="class in org.gearvrf">GVRScene</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#getMainScene--">getMainScene</a></span>()</code>
<div class="block">Get the current <a href="../../org/gearvrf/GVRScene.html" title="class in org.gearvrf"><code>GVRScene</code></a>, which contains the scene graph (a
 hierarchy of <a href="../../org/gearvrf/GVRSceneObject.html" title="class in org.gearvrf">scene objects</a>) and the
 <a href="../../org/gearvrf/GVRCameraRig.html" title="class in org.gearvrf">camera rig</a></div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code><a href="../../org/gearvrf/GVRMaterialShaderManager.html" title="class in org.gearvrf">GVRMaterialShaderManager</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#getMaterialShaderManager--">getMaterialShaderManager</a></span>()</code>
<div class="block">The <a href="../../org/gearvrf/GVRMaterialShaderManager.html" title="class in org.gearvrf">object shader manager</a>
 singleton.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code><a href="../../org/gearvrf/GVRScene.html" title="class in org.gearvrf">GVRScene</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#getNextMainScene--">getNextMainScene</a></span>()</code>
<div class="block">Returns a <a href="../../org/gearvrf/GVRScene.html" title="class in org.gearvrf"><code>GVRScene</code></a> that you can populate before passing to
 <a href="../../org/gearvrf/GVRContext.html#setMainScene-org.gearvrf.GVRScene-"><code>setMainScene(GVRScene)</code></a>.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>abstract <a href="../../org/gearvrf/GVRScene.html" title="class in org.gearvrf">GVRScene</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#getNextMainScene-java.lang.Runnable-">getNextMainScene</a></span>(java.lang.Runnable&nbsp;onSwitchMainScene)</code>
<div class="block">Returns a <a href="../../org/gearvrf/GVRScene.html" title="class in org.gearvrf"><code>GVRScene</code></a> that you can populate before passing to
 <a href="../../org/gearvrf/GVRContext.html#setMainScene-org.gearvrf.GVRScene-"><code>setMainScene(GVRScene)</code></a>.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code><a href="../../org/gearvrf/periodic/GVRPeriodicEngine.html" title="class in org.gearvrf.periodic">GVRPeriodicEngine</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#getPeriodicEngine--">getPeriodicEngine</a></span>()</code>
<div class="block">The <a href="../../org/gearvrf/periodic/GVRPeriodicEngine.html" title="class in org.gearvrf.periodic">periodic engine</a> singleton.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code><a href="../../org/gearvrf/GVRPostEffectShaderManager.html" title="class in org.gearvrf">GVRPostEffectShaderManager</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#getPostEffectShaderManager--">getPostEffectShaderManager</a></span>()</code>
<div class="block">The <a href="../../org/gearvrf/GVRPostEffectShaderManager.html" title="class in org.gearvrf">scene shader manager</a>
 singleton.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>abstract boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#isKeyDown-int-">isKeyDown</a></span>(int&nbsp;keyCode)</code>
<div class="block">Is the key pressed?</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>Bitmap</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#loadBitmap-java.lang.String-">loadBitmap</a></span>(java.lang.String&nbsp;fileName)</code>
<div class="block">Loads file placed in the assets folder, as a <code>Bitmap</code>.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#loadBitmapTexture-org.gearvrf.GVRAndroidResource.BitmapTextureCallback-org.gearvrf.GVRAndroidResource-">loadBitmapTexture</a></span>(<a href="../../org/gearvrf/GVRAndroidResource.BitmapTextureCallback.html" title="interface in org.gearvrf">GVRAndroidResource.BitmapTextureCallback</a>&nbsp;callback,
                 <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource)</code>
<div class="block">Load a bitmap, asynchronously, with a default priority.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#loadBitmapTexture-org.gearvrf.GVRAndroidResource.BitmapTextureCallback-org.gearvrf.GVRAndroidResource-int-">loadBitmapTexture</a></span>(<a href="../../org/gearvrf/GVRAndroidResource.BitmapTextureCallback.html" title="interface in org.gearvrf">GVRAndroidResource.BitmapTextureCallback</a>&nbsp;callback,
                 <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource,
                 int&nbsp;priority)</code>
<div class="block">Load a bitmap, asynchronously, with an explicit priority.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#loadCompressedTexture-org.gearvrf.GVRAndroidResource.CompressedTextureCallback-org.gearvrf.GVRAndroidResource-">loadCompressedTexture</a></span>(<a href="../../org/gearvrf/GVRAndroidResource.CompressedTextureCallback.html" title="interface in org.gearvrf">GVRAndroidResource.CompressedTextureCallback</a>&nbsp;callback,
                     <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource)</code>
<div class="block">Load a compressed texture, asynchronously.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#loadCompressedTexture-org.gearvrf.GVRAndroidResource.CompressedTextureCallback-org.gearvrf.GVRAndroidResource-int-">loadCompressedTexture</a></span>(<a href="../../org/gearvrf/GVRAndroidResource.CompressedTextureCallback.html" title="interface in org.gearvrf">GVRAndroidResource.CompressedTextureCallback</a>&nbsp;callback,
                     <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource,
                     int&nbsp;quality)</code>
<div class="block">Load a compressed texture, asynchronously.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code><a href="../../org/gearvrf/GVRCubemapTexture.html" title="class in org.gearvrf">GVRCubemapTexture</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#loadCubemapTexture-org.gearvrf.GVRAndroidResource:A-">loadCubemapTexture</a></span>(<a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>[]&nbsp;resourceArray)</code>
<div class="block">Loads a cube map texture synchronously.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>java.util.concurrent.Future&lt;<a href="../../org/gearvrf/GVRTexture.html" title="class in org.gearvrf">GVRTexture</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#loadFutureCubemapTexture-org.gearvrf.GVRAndroidResource-">loadFutureCubemapTexture</a></span>(<a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource)</code>
<div class="block">Simple, high-level method to load a cube map texture asynchronously, for
 use with <a href="../../org/gearvrf/GVRShaders.html#setMainTexture-java.util.concurrent.Future-"><code>GVRShaders.setMainTexture(Future)</code></a> and
 <a href="../../org/gearvrf/GVRShaders.html#setTexture-java.lang.String-java.util.concurrent.Future-"><code>GVRShaders.setTexture(String, Future)</code></a>.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>java.util.concurrent.Future&lt;<a href="../../org/gearvrf/GVRMesh.html" title="class in org.gearvrf">GVRMesh</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#loadFutureMesh-org.gearvrf.GVRAndroidResource-">loadFutureMesh</a></span>(<a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource)</code>
<div class="block">Simple, high-level method to load a mesh asynchronously, for use with
 <a href="../../org/gearvrf/GVRRenderData.html#setMesh-java.util.concurrent.Future-"><code>GVRRenderData.setMesh(Future)</code></a>.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>java.util.concurrent.Future&lt;<a href="../../org/gearvrf/GVRMesh.html" title="class in org.gearvrf">GVRMesh</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#loadFutureMesh-org.gearvrf.GVRAndroidResource-int-">loadFutureMesh</a></span>(<a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource,
              int&nbsp;priority)</code>
<div class="block">Simple, high-level method to load a mesh asynchronously, for use with
 <a href="../../org/gearvrf/GVRRenderData.html#setMesh-java.util.concurrent.Future-"><code>GVRRenderData.setMesh(Future)</code></a>.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>java.util.concurrent.Future&lt;<a href="../../org/gearvrf/GVRTexture.html" title="class in org.gearvrf">GVRTexture</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#loadFutureTexture-org.gearvrf.GVRAndroidResource-">loadFutureTexture</a></span>(<a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource)</code>
<div class="block">Simple, high-level method to load a texture asynchronously, for use with
 <a href="../../org/gearvrf/GVRShaders.html#setMainTexture-java.util.concurrent.Future-"><code>GVRShaders.setMainTexture(Future)</code></a> and
 <a href="../../org/gearvrf/GVRShaders.html#setTexture-java.lang.String-java.util.concurrent.Future-"><code>GVRShaders.setTexture(String, Future)</code></a>.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>java.util.concurrent.Future&lt;<a href="../../org/gearvrf/GVRTexture.html" title="class in org.gearvrf">GVRTexture</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#loadFutureTexture-org.gearvrf.GVRAndroidResource-int-">loadFutureTexture</a></span>(<a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource,
                 int&nbsp;priority)</code>
<div class="block">Simple, high-level method to load a texture asynchronously, for use with
 <a href="../../org/gearvrf/GVRShaders.html#setMainTexture-java.util.concurrent.Future-"><code>GVRShaders.setMainTexture(Future)</code></a> and
 <a href="../../org/gearvrf/GVRShaders.html#setTexture-java.lang.String-java.util.concurrent.Future-"><code>GVRShaders.setTexture(String, Future)</code></a>.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>java.util.concurrent.Future&lt;<a href="../../org/gearvrf/GVRTexture.html" title="class in org.gearvrf">GVRTexture</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#loadFutureTexture-org.gearvrf.GVRAndroidResource-int-int-">loadFutureTexture</a></span>(<a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource,
                 int&nbsp;priority,
                 int&nbsp;quality)</code>
<div class="block">Simple, high-level method to load a texture asynchronously, for use with
 <a href="../../org/gearvrf/GVRShaders.html#setMainTexture-java.util.concurrent.Future-"><code>GVRShaders.setMainTexture(Future)</code></a> and
 <a href="../../org/gearvrf/GVRShaders.html#setTexture-java.lang.String-java.util.concurrent.Future-"><code>GVRShaders.setTexture(String, Future)</code></a>.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#loadMesh-org.gearvrf.GVRAndroidResource.MeshCallback-org.gearvrf.GVRAndroidResource-">loadMesh</a></span>(<a href="../../org/gearvrf/GVRAndroidResource.MeshCallback.html" title="interface in org.gearvrf">GVRAndroidResource.MeshCallback</a>&nbsp;callback,
        <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;androidResource)</code>
<div class="block">Loads a mesh file, asynchronously, at a default priority.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#loadMesh-org.gearvrf.GVRAndroidResource.MeshCallback-org.gearvrf.GVRAndroidResource-int-">loadMesh</a></span>(<a href="../../org/gearvrf/GVRAndroidResource.MeshCallback.html" title="interface in org.gearvrf">GVRAndroidResource.MeshCallback</a>&nbsp;callback,
        <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource,
        int&nbsp;priority)</code>
<div class="block">Loads a mesh file, asynchronously, at an explicit priority.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code><a href="../../org/gearvrf/GVRMesh.html" title="class in org.gearvrf">GVRMesh</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#loadMesh-org.gearvrf.GVRAndroidResource-">loadMesh</a></span>(<a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;androidResource)</code>
<div class="block">Loads a file as a <a href="../../org/gearvrf/GVRMesh.html" title="class in org.gearvrf"><code>GVRMesh</code></a>.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#loadTexture-org.gearvrf.GVRAndroidResource.TextureCallback-org.gearvrf.GVRAndroidResource-">loadTexture</a></span>(<a href="../../org/gearvrf/GVRAndroidResource.TextureCallback.html" title="interface in org.gearvrf">GVRAndroidResource.TextureCallback</a>&nbsp;callback,
           <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource)</code>
<div class="block">A simplified, low-level method that loads a texture asynchronously,
 without making you specify
 <a href="../../org/gearvrf/GVRContext.html#loadBitmapTexture-org.gearvrf.GVRAndroidResource.BitmapTextureCallback-org.gearvrf.GVRAndroidResource-"><code>loadBitmapTexture()</code></a> or
 <a href="../../org/gearvrf/GVRContext.html#loadCompressedTexture-org.gearvrf.GVRAndroidResource.CompressedTextureCallback-org.gearvrf.GVRAndroidResource-"><code>loadCompressedTexture()</code></a>.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#loadTexture-org.gearvrf.GVRAndroidResource.TextureCallback-org.gearvrf.GVRAndroidResource-int-">loadTexture</a></span>(<a href="../../org/gearvrf/GVRAndroidResource.TextureCallback.html" title="interface in org.gearvrf">GVRAndroidResource.TextureCallback</a>&nbsp;callback,
           <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource,
           int&nbsp;priority)</code>
<div class="block">A simplified, low-level method that loads a texture asynchronously,
 without making you specify
 <a href="../../org/gearvrf/GVRContext.html#loadBitmapTexture-org.gearvrf.GVRAndroidResource.BitmapTextureCallback-org.gearvrf.GVRAndroidResource-"><code>loadBitmapTexture()</code></a> or
 <a href="../../org/gearvrf/GVRContext.html#loadCompressedTexture-org.gearvrf.GVRAndroidResource.CompressedTextureCallback-org.gearvrf.GVRAndroidResource-"><code>loadCompressedTexture()</code></a>.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#loadTexture-org.gearvrf.GVRAndroidResource.TextureCallback-org.gearvrf.GVRAndroidResource-int-int-">loadTexture</a></span>(<a href="../../org/gearvrf/GVRAndroidResource.TextureCallback.html" title="interface in org.gearvrf">GVRAndroidResource.TextureCallback</a>&nbsp;callback,
           <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource,
           int&nbsp;priority,
           int&nbsp;quality)</code>
<div class="block">A simplified, low-level method that loads a texture asynchronously,
 without making you specify
 <a href="../../org/gearvrf/GVRContext.html#loadBitmapTexture-org.gearvrf.GVRAndroidResource.BitmapTextureCallback-org.gearvrf.GVRAndroidResource-"><code>loadBitmapTexture()</code></a> or
 <a href="../../org/gearvrf/GVRContext.html#loadCompressedTexture-org.gearvrf.GVRAndroidResource.CompressedTextureCallback-org.gearvrf.GVRAndroidResource-"><code>loadCompressedTexture()</code></a>.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code><a href="../../org/gearvrf/GVRBitmapTexture.html" title="class in org.gearvrf">GVRBitmapTexture</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#loadTexture-org.gearvrf.GVRAndroidResource-">loadTexture</a></span>(<a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource)</code>
<div class="block">Loads file placed in the assets folder, as a <a href="../../org/gearvrf/GVRBitmapTexture.html" title="class in org.gearvrf"><code>GVRBitmapTexture</code></a>.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code><a href="../../org/gearvrf/GVRBitmapTexture.html" title="class in org.gearvrf">GVRBitmapTexture</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#loadTexture-java.lang.String-">loadTexture</a></span>(java.lang.String&nbsp;fileName)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">We will remove this blocking function during Q3 of 2015. We
             suggest that you switch to
             <a href="../../org/gearvrf/GVRContext.html#loadTexture-org.gearvrf.GVRAndroidResource-"><code>loadTexture(GVRAndroidResource)</code></a></span></div>
</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#registerDrawFrameListener-org.gearvrf.GVRDrawFrameListener-">registerDrawFrameListener</a></span>(<a href="../../org/gearvrf/GVRDrawFrameListener.html" title="interface in org.gearvrf">GVRDrawFrameListener</a>&nbsp;frameListener)</code>
<div class="block">Subscribes a <a href="../../org/gearvrf/GVRDrawFrameListener.html" title="interface in org.gearvrf"><code>GVRDrawFrameListener</code></a>.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#runOnGlThread-java.lang.Runnable-">runOnGlThread</a></span>(java.lang.Runnable&nbsp;runnable)</code>
<div class="block">Enqueues a callback to be run in the GL thread.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#setMainScene-org.gearvrf.GVRScene-">setMainScene</a></span>(<a href="../../org/gearvrf/GVRScene.html" title="class in org.gearvrf">GVRScene</a>&nbsp;scene)</code>
<div class="block">Set the current <a href="../../org/gearvrf/GVRScene.html" title="class in org.gearvrf"><code>GVRScene</code></a></div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../org/gearvrf/GVRContext.html#unregisterDrawFrameListener-org.gearvrf.GVRDrawFrameListener-">unregisterDrawFrameListener</a></span>(<a href="../../org/gearvrf/GVRDrawFrameListener.html" title="interface in org.gearvrf">GVRDrawFrameListener</a>&nbsp;frameListener)</code>
<div class="block">Remove a previously-subscribed <a href="../../org/gearvrf/GVRDrawFrameListener.html" title="interface in org.gearvrf"><code>GVRDrawFrameListener</code></a>.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="RESERVED_PRIORITIES">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RESERVED_PRIORITIES</h4>
<pre>public static final&nbsp;int RESERVED_PRIORITIES</pre>
<div class="block">GVRF can't use every <code>int</code> as a priority - it needs some sentinel
 values. It will probably never need anywhere near this many, but raising
 the number of reserved values narrows the 'dynamic range' available to
 apps mapping some internal score to the <a href="../../org/gearvrf/GVRContext.html#LOWEST_PRIORITY"><code>LOWEST_PRIORITY</code></a> to
 <a href="../../org/gearvrf/GVRContext.html#HIGHEST_PRIORITY"><code>HIGHEST_PRIORITY</code></a> range, and might change app behavior in subtle
 ways that seem best avoided.</div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6.1</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#org.gearvrf.GVRContext.RESERVED_PRIORITIES">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="LOWEST_PRIORITY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LOWEST_PRIORITY</h4>
<pre>public static final&nbsp;int LOWEST_PRIORITY</pre>
<div class="block">GVRF can't use every <code>int</code> as a priority - it needs some sentinel
 values. A simple approach to generating priorities is to score resources
 from 0 to 1, and then map that to the range <a href="../../org/gearvrf/GVRContext.html#LOWEST_PRIORITY"><code>LOWEST_PRIORITY</code></a> to
 <a href="../../org/gearvrf/GVRContext.html#HIGHEST_PRIORITY"><code>HIGHEST_PRIORITY</code></a>.</div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6.1</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#org.gearvrf.GVRContext.LOWEST_PRIORITY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="HIGHEST_PRIORITY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HIGHEST_PRIORITY</h4>
<pre>public static final&nbsp;int HIGHEST_PRIORITY</pre>
<div class="block">GVRF can't use every <code>int</code> as a priority - it needs some sentinel
 values. A simple approach to generating priorities is to score resources
 from 0 to 1, and then map that to the range <a href="../../org/gearvrf/GVRContext.html#LOWEST_PRIORITY"><code>LOWEST_PRIORITY</code></a> to
 <a href="../../org/gearvrf/GVRContext.html#HIGHEST_PRIORITY"><code>HIGHEST_PRIORITY</code></a>.</div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6.1</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#org.gearvrf.GVRContext.HIGHEST_PRIORITY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DEFAULT_PRIORITY">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>DEFAULT_PRIORITY</h4>
<pre>public static final&nbsp;int DEFAULT_PRIORITY</pre>
<div class="block">The priority used by
 <a href="../../org/gearvrf/GVRContext.html#loadBitmapTexture-org.gearvrf.GVRAndroidResource.BitmapTextureCallback-org.gearvrf.GVRAndroidResource-"><code>loadBitmapTexture(GVRAndroidResource.BitmapTextureCallback, GVRAndroidResource)</code></a>
 and
 <a href="../../org/gearvrf/GVRContext.html#loadMesh-org.gearvrf.GVRAndroidResource.MeshCallback-org.gearvrf.GVRAndroidResource-"><code>loadMesh(GVRAndroidResource.MeshCallback, GVRAndroidResource)</code></a></div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6.1</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#org.gearvrf.GVRContext.DEFAULT_PRIORITY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="getContext--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getContext</h4>
<pre>public&nbsp;Context&nbsp;getContext()</pre>
<div class="block">Get the Android <code>Context</code>, which provides access to system services
 and to your application's resources. Since version 2.0.1, this is
 actually your <a href="../../org/gearvrf/GVRActivity.html" title="class in org.gearvrf"><code>GVRActivity</code></a> implementation, but you should probably
 use the new <a href="../../org/gearvrf/GVRContext.html#getActivity--"><code>getActivity()</code></a> method, rather than casting this
 method to an <code>(Activity)</code> or <code>(GVRActivity)</code>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An Android <code>Context</code></dd>
</dl>
</li>
</ul>
<a name="getActivity--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getActivity</h4>
<pre>public&nbsp;<a href="../../org/gearvrf/GVRActivity.html" title="class in org.gearvrf">GVRActivity</a>&nbsp;getActivity()</pre>
<div class="block">Get the Android <code>Activity</code> which launched your GVRF app.
 
 An <code>Activity</code> is-a <code>Context</code> and so provides access to system
 services and to your application's resources; the <code>Activity</code> class
 also provides additional services, including
 <code>Activity#runOnUiThread(Runnable)</code>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The <a href="../../org/gearvrf/GVRActivity.html" title="class in org.gearvrf"><code>GVRActivity</code></a> which launched your GVRF app. The
         <a href="../../org/gearvrf/GVRActivity.html" title="class in org.gearvrf"><code>GVRActivity</code></a> class doesn't actually add much useful
         functionality besides
         <a href="../../org/gearvrf/GVRActivity.html#setScript-org.gearvrf.GVRScript-java.lang.String-"><code>GVRActivity.setScript(GVRScript, String)</code></a>, but returning
         the most-derived class here may prevent someone from having to
         write <code>(GVRActivity) gvrContext.getActivity();</code>.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2.0.1</dd>
</dl>
</li>
</ul>
<a name="loadMesh-org.gearvrf.GVRAndroidResource-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadMesh</h4>
<pre>public&nbsp;<a href="../../org/gearvrf/GVRMesh.html" title="class in org.gearvrf">GVRMesh</a>&nbsp;loadMesh(<a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;androidResource)</pre>
<div class="block">Loads a file as a <a href="../../org/gearvrf/GVRMesh.html" title="class in org.gearvrf"><code>GVRMesh</code></a>.
 
 Note that this method can be quite slow; we recommend never calling it
 from the GL thread. The asynchronous version
 <a href="../../org/gearvrf/GVRContext.html#loadMesh-org.gearvrf.GVRAndroidResource.MeshCallback-org.gearvrf.GVRAndroidResource-"><code>loadMesh(GVRAndroidResource.MeshCallback, GVRAndroidResource)</code></a> is
 better because it moves most of the work to a background thread, doing as
 little as possible on the GL thread.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>androidResource</code> - Basically, a stream containing a 3D model. The
            <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> class has six constructors to
            handle a wide variety of Android resource types. Taking a
            <code>GVRAndroidResource</code> here eliminates six overloads.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The file as a GL mesh.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6.2</dd>
</dl>
</li>
</ul>
<a name="loadMesh-org.gearvrf.GVRAndroidResource.MeshCallback-org.gearvrf.GVRAndroidResource-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadMesh</h4>
<pre>public&nbsp;void&nbsp;loadMesh(<a href="../../org/gearvrf/GVRAndroidResource.MeshCallback.html" title="interface in org.gearvrf">GVRAndroidResource.MeshCallback</a>&nbsp;callback,
                     <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;androidResource)
              throws java.lang.IllegalArgumentException</pre>
<div class="block">Loads a mesh file, asynchronously, at a default priority.
 
 This method and the
 <a href="../../org/gearvrf/GVRContext.html#loadMesh-org.gearvrf.GVRAndroidResource.MeshCallback-org.gearvrf.GVRAndroidResource-int-">overload that takes a priority</a> are generally going to be your best
 choices for loading <a href="../../org/gearvrf/GVRMesh.html" title="class in org.gearvrf"><code>GVRMesh</code></a> resources: mesh loading can take
 hundreds - and even thousands - of milliseconds, and so should not be
 done on the GL thread in either <a href="../../org/gearvrf/GVRScript.html#onInit-org.gearvrf.GVRContext-"><code>onInit()</code></a> or <a href="../../org/gearvrf/GVRScript.html#onStep--"><code>onStep()</code></a>.
 
 <p>
 The asynchronous methods improve throughput in three ways. First, by
 doing all the work on a background thread, then delivering the loaded
 mesh to the GL thread on a <a href="../../org/gearvrf/GVRContext.html#runOnGlThread-java.lang.Runnable-"><code>runOnGlThread()</code></a> callback. Second, they use a throttler to avoid
 overloading the system and/or running out of memory. Third, they do
 'request consolidation' - if you issue any requests for a particular file
 while there is still a pending request, the file will only be read once,
 and each callback will get the same <a href="../../org/gearvrf/GVRMesh.html" title="class in org.gearvrf"><code>GVRMesh</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>callback</code> - App supplied callback, with three different methods.
            <ul>
            <li>Before loading, GVRF may call
            <a href="../../org/gearvrf/GVRAndroidResource.CancelableCallback.html#stillWanted-org.gearvrf.GVRAndroidResource-"><code>stillWanted()</code></a> (on a background thread) to give you a chance
            to abort a 'stale' load.
 
            <li>Successful loads will call
            <a href="../../org/gearvrf/GVRAndroidResource.Callback.html#loaded-T-org.gearvrf.GVRAndroidResource-"><code>loaded()</code></a> on the GL thread.
 
            <li>Any errors will call
            <a href="../../org/gearvrf/GVRAndroidResource.Callback.html#failed-java.lang.Throwable-org.gearvrf.GVRAndroidResource-"><code>failed(),</code></a> with no promises about threading.
            </ul></dd>
<dd><code>androidResource</code> - Basically, a stream containing a 3D model. The
            <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> class has six constructors to
            handle a wide variety of Android resource types. Taking a
            <code>GVRAndroidResource</code> here eliminates six overloads.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If either parameter is <code>null</code> or if you 'abuse' request
             consolidation by passing the same <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a>
             descriptor to multiple load calls.
             <p>
             It's fairly common for multiple scene objects to use the same
             texture or the same mesh. Thus, if you try to load, say,
             <code>R.raw.whatever</code> while you already have a pending
             request for <code>R.raw.whatever</code>, it will only be loaded
             once; the same resource will be used to satisfy both (all)
             requests. This "consolidation" uses
             <a href="../../org/gearvrf/GVRAndroidResource.html#equals-java.lang.Object-"><code>GVRAndroidResource.equals(Object)</code></a>, <em>not</em>
             <code>==</code> (aka "reference equality"): The problem with using
             the same resource descriptor is that if requests can't be
             consolidated (because the later one(s) came in after the
             earlier one(s) had already completed) the resource will be
             reloaded ... but the original descriptor will have been
             closed.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6.2</dd>
</dl>
</li>
</ul>
<a name="loadMesh-org.gearvrf.GVRAndroidResource.MeshCallback-org.gearvrf.GVRAndroidResource-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadMesh</h4>
<pre>public&nbsp;void&nbsp;loadMesh(<a href="../../org/gearvrf/GVRAndroidResource.MeshCallback.html" title="interface in org.gearvrf">GVRAndroidResource.MeshCallback</a>&nbsp;callback,
                     <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource,
                     int&nbsp;priority)
              throws java.lang.IllegalArgumentException</pre>
<div class="block">Loads a mesh file, asynchronously, at an explicit priority.
 
 This method and the
 <a href="../../org/gearvrf/GVRContext.html#loadMesh-org.gearvrf.GVRAndroidResource.MeshCallback-org.gearvrf.GVRAndroidResource-">overload that supplies a default priority</a> are generally going to be your
 best choices for loading <a href="../../org/gearvrf/GVRMesh.html" title="class in org.gearvrf"><code>GVRMesh</code></a> resources: mesh loading can take
 hundreds - and even thousands - of milliseconds, and so should not be
 done on the GL thread in either <a href="../../org/gearvrf/GVRScript.html#onInit-org.gearvrf.GVRContext-"><code>onInit()</code></a> or <a href="../../org/gearvrf/GVRScript.html#onStep--"><code>onStep()</code></a>.
 
 <p>
 The asynchronous methods improve throughput in three ways. First, by
 doing all the work on a background thread, then delivering the loaded
 mesh to the GL thread on a <a href="../../org/gearvrf/GVRContext.html#runOnGlThread-java.lang.Runnable-"><code>runOnGlThread()</code></a> callback. Second, they use a throttler to avoid
 overloading the system and/or running out of memory. Third, they do
 'request consolidation' - if you issue any requests for a particular file
 while there is still a pending request, the file will only be read once,
 and each callback will get the same <a href="../../org/gearvrf/GVRMesh.html" title="class in org.gearvrf"><code>GVRMesh</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>callback</code> - App supplied callback, with three different methods.
            <ul>
            <li>Before loading, GVRF may call
            <a href="../../org/gearvrf/GVRAndroidResource.CancelableCallback.html#stillWanted-org.gearvrf.GVRAndroidResource-"><code>stillWanted()</code></a> (on a background thread) to give you a chance
            to abort a 'stale' load.
 
            <li>Successful loads will call
            <a href="../../org/gearvrf/GVRAndroidResource.Callback.html#loaded-T-org.gearvrf.GVRAndroidResource-"><code>loaded()</code></a> on the GL thread.
 
            <li>Any errors will call
            <a href="../../org/gearvrf/GVRAndroidResource.Callback.html#failed-java.lang.Throwable-org.gearvrf.GVRAndroidResource-"><code>failed(),</code></a> with no promises about threading.
            </ul></dd>
<dd><code>resource</code> - Basically, a stream containing a 3D model. The
            <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> class has six constructors to
            handle a wide variety of Android resource types. Taking a
            <code>GVRAndroidResource</code> here eliminates six overloads.</dd>
<dd><code>priority</code> - This request's priority. Please see the notes on asynchronous
            priorities in the <a href="package-summary.html#async">package
            description</a>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If either <code>callback</code> or <code>resource</code> is
             <code>null</code>, or if <code>priority</code> is out of range - or if
             you 'abuse' request consolidation by passing the same
             <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> descriptor to multiple load calls.
             <p>
             It's fairly common for multiple scene objects to use the same
             texture or the same mesh. Thus, if you try to load, say,
             <code>R.raw.whatever</code> while you already have a pending
             request for <code>R.raw.whatever</code>, it will only be loaded
             once; the same resource will be used to satisfy both (all)
             requests. This "consolidation" uses
             <a href="../../org/gearvrf/GVRAndroidResource.html#equals-java.lang.Object-"><code>GVRAndroidResource.equals(Object)</code></a>, <em>not</em>
             <code>==</code> (aka "reference equality"): The problem with using
             the same resource descriptor is that if requests can't be
             consolidated (because the later one(s) came in after the
             earlier one(s) had already completed) the resource will be
             reloaded ... but the original descriptor will have been
             closed.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6.2</dd>
</dl>
</li>
</ul>
<a name="loadFutureMesh-org.gearvrf.GVRAndroidResource-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadFutureMesh</h4>
<pre>public&nbsp;java.util.concurrent.Future&lt;<a href="../../org/gearvrf/GVRMesh.html" title="class in org.gearvrf">GVRMesh</a>&gt;&nbsp;loadFutureMesh(<a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource)</pre>
<div class="block">Simple, high-level method to load a mesh asynchronously, for use with
 <a href="../../org/gearvrf/GVRRenderData.html#setMesh-java.util.concurrent.Future-"><code>GVRRenderData.setMesh(Future)</code></a>.
 
 This method uses a default priority; use
 <a href="../../org/gearvrf/GVRContext.html#loadFutureMesh-org.gearvrf.GVRAndroidResource-int-"><code>loadFutureMesh(GVRAndroidResource, int)</code></a> to specify a priority;
 use one of the lower-level
 <a href="../../org/gearvrf/GVRContext.html#loadMesh-org.gearvrf.GVRAndroidResource.MeshCallback-org.gearvrf.GVRAndroidResource-"><code>loadMesh(GVRAndroidResource.MeshCallback, GVRAndroidResource)</code></a>
 methods to get more control over loading.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>resource</code> - Basically, a stream containing a 3D model. The
            <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> class has six constructors to
            handle a wide variety of Android resource types. Taking a
            <code>GVRAndroidResource</code> here eliminates six overloads.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <code>Future</code> that you can pass to
         <a href="../../org/gearvrf/GVRRenderData.html#setMesh-java.util.concurrent.Future-"><code>GVRRenderData.setMesh(Future)</code></a></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If you 'abuse' request consolidation by passing the same
             <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> descriptor to multiple load calls.
             <p>
             It's fairly common for multiple scene objects to use the same
             texture or the same mesh. Thus, if you try to load, say,
             <code>R.raw.whatever</code> while you already have a pending
             request for <code>R.raw.whatever</code>, it will only be loaded
             once; the same resource will be used to satisfy both (all)
             requests. This "consolidation" uses
             <a href="../../org/gearvrf/GVRAndroidResource.html#equals-java.lang.Object-"><code>GVRAndroidResource.equals(Object)</code></a>, <em>not</em>
             <code>==</code> (aka "reference equality"): The problem with using
             the same resource descriptor is that if requests can't be
             consolidated (because the later one(s) came in after the
             earlier one(s) had already completed) the resource will be
             reloaded ... but the original descriptor will have been
             closed.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6.7</dd>
</dl>
</li>
</ul>
<a name="loadFutureMesh-org.gearvrf.GVRAndroidResource-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadFutureMesh</h4>
<pre>public&nbsp;java.util.concurrent.Future&lt;<a href="../../org/gearvrf/GVRMesh.html" title="class in org.gearvrf">GVRMesh</a>&gt;&nbsp;loadFutureMesh(<a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource,
                                                           int&nbsp;priority)</pre>
<div class="block">Simple, high-level method to load a mesh asynchronously, for use with
 <a href="../../org/gearvrf/GVRRenderData.html#setMesh-java.util.concurrent.Future-"><code>GVRRenderData.setMesh(Future)</code></a>.
 
 This method trades control for convenience; use one of the lower-level
 <a href="../../org/gearvrf/GVRContext.html#loadMesh-org.gearvrf.GVRAndroidResource.MeshCallback-org.gearvrf.GVRAndroidResource-"><code>loadMesh(GVRAndroidResource.MeshCallback, GVRAndroidResource)</code></a>
 methods if, say, you want to do something more than just
 <a href="../../org/gearvrf/GVRRenderData.html#setMesh-org.gearvrf.GVRMesh-"><code>GVRRenderData.setMesh(GVRMesh)</code></a> when the mesh loads.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>resource</code> - Basically, a stream containing a 3D model. The
            <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> class has six constructors to
            handle a wide variety of Android resource types. Taking a
            <code>GVRAndroidResource</code> here eliminates six overloads.</dd>
<dd><code>priority</code> - This request's priority. Please see the notes on asynchronous
            priorities in the <a href="package-summary.html#async">package
            description</a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <code>Future</code> that you can pass to
         <a href="../../org/gearvrf/GVRRenderData.html#setMesh-java.util.concurrent.Future-"><code>GVRRenderData.setMesh(Future)</code></a></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If you 'abuse' request consolidation by passing the same
             <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> descriptor to multiple load calls.
             <p>
             It's fairly common for multiple scene objects to use the same
             texture or the same mesh. Thus, if you try to load, say,
             <code>R.raw.whatever</code> while you already have a pending
             request for <code>R.raw.whatever</code>, it will only be loaded
             once; the same resource will be used to satisfy both (all)
             requests. This "consolidation" uses
             <a href="../../org/gearvrf/GVRAndroidResource.html#equals-java.lang.Object-"><code>GVRAndroidResource.equals(Object)</code></a>, <em>not</em>
             <code>==</code> (aka "reference equality"): The problem with using
             the same resource descriptor is that if requests can't be
             consolidated (because the later one(s) came in after the
             earlier one(s) had already completed) the resource will be
             reloaded ... but the original descriptor will have been
             closed.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6.7</dd>
</dl>
</li>
</ul>
<a name="createQuad-float-float-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createQuad</h4>
<pre>public&nbsp;<a href="../../org/gearvrf/GVRMesh.html" title="class in org.gearvrf">GVRMesh</a>&nbsp;createQuad(float&nbsp;width,
                          float&nbsp;height)</pre>
<div class="block">Creates a quad consisting of two triangles, with the specified width and
 height.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>width</code> - the quad's width</dd>
<dd><code>height</code> - the quad's height</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A 2D, rectangular mesh with four vertices and two triangles</dd>
</dl>
</li>
</ul>
<a name="loadBitmap-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadBitmap</h4>
<pre>public&nbsp;Bitmap&nbsp;loadBitmap(java.lang.String&nbsp;fileName)</pre>
<div class="block">Loads file placed in the assets folder, as a <code>Bitmap</code>.
 
 <p>
 Note that this method may take hundreds of milliseconds to return: unless
 the bitmap is quite tiny, you probably don't want to call this directly
 from your <a href="../../org/gearvrf/GVRScript.html#onStep--"><code>onStep()</code></a> callback as that is called
 once per frame, and a long call will cause you to miss frames.
 
 <p>
 Note also that this method does no scaling, and will return a full-size
 <code>Bitmap</code>. Loading (say) an unscaled photograph may abort your app:
 Use pre-scaled images, or <code>BitmapFactory</code> methods which give you
 more control over the image size.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>fileName</code> - The name of a file, relative to the assets directory. The
            assets directory may contain an arbitrarily complex tree of
            subdirectories; the file name can specify any location in or
            under the assets directory.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The file as a bitmap, or <code>null</code> if file path does not exist
         or the file can not be decoded into a Bitmap.</dd>
</dl>
</li>
</ul>
<a name="loadTexture-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadTexture</h4>
<pre>public&nbsp;<a href="../../org/gearvrf/GVRBitmapTexture.html" title="class in org.gearvrf">GVRBitmapTexture</a>&nbsp;loadTexture(java.lang.String&nbsp;fileName)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">We will remove this blocking function during Q3 of 2015. We
             suggest that you switch to
             <a href="../../org/gearvrf/GVRContext.html#loadTexture-org.gearvrf.GVRAndroidResource-"><code>loadTexture(GVRAndroidResource)</code></a></span></div>
<div class="block">Loads file placed in the assets folder, as a <a href="../../org/gearvrf/GVRBitmapTexture.html" title="class in org.gearvrf"><code>GVRBitmapTexture</code></a>.
 
 <p>
 Note that this method may take hundreds of milliseconds to return: unless
 the texture is quite tiny, you probably don't want to call this directly
 from your <a href="../../org/gearvrf/GVRScript.html#onStep--"><code>onStep()</code></a> callback as that is called
 once per frame, and a long call will cause you to miss frames. For large
 images, you should use either
 <a href="../../org/gearvrf/GVRContext.html#loadBitmapTexture-org.gearvrf.GVRAndroidResource.BitmapTextureCallback-org.gearvrf.GVRAndroidResource-"><code>loadBitmapTexture()</code></a> (faster) or
 <a href="../../org/gearvrf/GVRContext.html#loadCompressedTexture-org.gearvrf.GVRAndroidResource.CompressedTextureCallback-org.gearvrf.GVRAndroidResource-"><code>loadCompressedTexture(GVRAndroidResource.CompressedTextureCallback, GVRAndroidResource)</code></a>
 (fastest <em>and</em> least memory pressure).
 
 <p>
 Note also that this method does no scaling, and will return a full-size
 <code>Bitmap</code>. Loading (say) an unscaled photograph may abort your app:
 Use
 <ul>
 <li>Pre-scaled images
 <li><code>BitmapFactory</code> methods which give you more control over the
 image size, or
 <li>
 <a href="../../org/gearvrf/GVRContext.html#loadTexture-org.gearvrf.GVRAndroidResource-"><code>loadTexture(GVRAndroidResource)</code></a> or
 <a href="../../org/gearvrf/GVRContext.html#loadBitmapTexture-org.gearvrf.GVRAndroidResource.BitmapTextureCallback-org.gearvrf.GVRAndroidResource-"><code>loadBitmapTexture(GVRAndroidResource.BitmapTextureCallback, GVRAndroidResource)</code></a>
 which automatically scale large images to fit the GPU's restrictions and
 to avoid out of memory errors.
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>fileName</code> - The name of a file, relative to the assets directory. The
            assets directory may contain an arbitrarily complex tree of
            sub-directories; the file name can specify any location in or
            under the assets directory.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The file as a texture, or <code>null</code> if file path does not
         exist or the file can not be decoded into a Bitmap.</dd>
</dl>
</li>
</ul>
<a name="loadTexture-org.gearvrf.GVRAndroidResource-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadTexture</h4>
<pre>public&nbsp;<a href="../../org/gearvrf/GVRBitmapTexture.html" title="class in org.gearvrf">GVRBitmapTexture</a>&nbsp;loadTexture(<a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource)</pre>
<div class="block">Loads file placed in the assets folder, as a <a href="../../org/gearvrf/GVRBitmapTexture.html" title="class in org.gearvrf"><code>GVRBitmapTexture</code></a>.
 
 <p>
 Note that this method may take hundreds of milliseconds to return: unless
 the texture is quite tiny, you probably don't want to call this directly
 from your <a href="../../org/gearvrf/GVRScript.html#onStep--"><code>onStep()</code></a> callback as that is called
 once per frame, and a long call will cause you to miss frames. For large
 images, you should use either
 <a href="../../org/gearvrf/GVRContext.html#loadBitmapTexture-org.gearvrf.GVRAndroidResource.BitmapTextureCallback-org.gearvrf.GVRAndroidResource-"><code>loadBitmapTexture()</code></a> (faster) or
 <a href="../../org/gearvrf/GVRContext.html#loadCompressedTexture-org.gearvrf.GVRAndroidResource.CompressedTextureCallback-org.gearvrf.GVRAndroidResource-"><code>loadCompressedTexture(GVRAndroidResource.CompressedTextureCallback, GVRAndroidResource)</code></a>
 (fastest <em>and</em> least memory pressure).
 
 <p>
 This method automatically scales large images to fit the GPU's
 restrictions and to avoid out of memory
 errors. </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>resource</code> - Basically, a stream containing a bitmap texture. The
            <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> class has six constructors to
            handle a wide variety of Android resource types. Taking a
            <code>GVRAndroidResource</code> here eliminates six overloads.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The file as a texture, or <code>null</code> if the file can not be
         decoded into a Bitmap.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6.5</dd>
</dl>
</li>
</ul>
<a name="loadCubemapTexture-org.gearvrf.GVRAndroidResource:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadCubemapTexture</h4>
<pre>public&nbsp;<a href="../../org/gearvrf/GVRCubemapTexture.html" title="class in org.gearvrf">GVRCubemapTexture</a>&nbsp;loadCubemapTexture(<a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>[]&nbsp;resourceArray)</pre>
<div class="block">Loads a cube map texture synchronously.
 
 <p>
 Note that this method may take hundreds of milliseconds to return: unless
 the cube map is quite tiny, you probably don't want to call this directly
 from your <a href="../../org/gearvrf/GVRScript.html#onStep--"><code>onStep()</code></a> callback as that is called
 once per frame, and a long call will cause you to miss frames.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>resourceArray</code> - An array containing six resources for six bitmaps. The order
            of the bitmaps is important to the correctness of the cube map
            texture. The six bitmaps should correspond to +x, -x, +y, -y,
            +z, and -z faces of the cube map texture respectively.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The cube map texture, or <code>null</code> if the length of
         rsourceArray is not 6.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6.9</dd>
</dl>
</li>
</ul>
<a name="loadBitmapTexture-org.gearvrf.GVRAndroidResource.BitmapTextureCallback-org.gearvrf.GVRAndroidResource-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadBitmapTexture</h4>
<pre>public&nbsp;void&nbsp;loadBitmapTexture(<a href="../../org/gearvrf/GVRAndroidResource.BitmapTextureCallback.html" title="interface in org.gearvrf">GVRAndroidResource.BitmapTextureCallback</a>&nbsp;callback,
                              <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource)</pre>
<div class="block">Load a bitmap, asynchronously, with a default priority.
 
 Because it is asynchronous, this method <em>is</em> a bit harder to use
 than <a href="../../org/gearvrf/GVRContext.html#loadTexture-java.lang.String-"><code>loadTexture(String)</code></a>, but it moves a large amount of work
 (in <code>BitmapFactory#decodeStream(InputStream)</code> from the GL thread to
 a background thread. Since you <em>can</em> create a
 <a href="../../org/gearvrf/GVRSceneObject.html" title="class in org.gearvrf"><code>GVRSceneObject</code></a> without a mesh and texture - and set them later -
 using the asynchronous API can improve startup speed and/or reduce frame
 misses (where an <a href="../../org/gearvrf/GVRScript.html#onStep--"><code>onStep()</code></a> takes too long).
 This API may also use less RAM than <a href="../../org/gearvrf/GVRContext.html#loadTexture-java.lang.String-"><code>loadTexture(String)</code></a>.
 
 <p>
 This API will 'consolidate' requests: If you request a texture like
 <code>R.raw.wood_grain</code> and then - before it has loaded - issue another
 request for <code>R.raw.wood_grain</code>, GVRF will only read the bitmap file
 once; only create a single <a href="../../org/gearvrf/GVRTexture.html" title="class in org.gearvrf"><code>GVRTexture</code></a>; and then call both
 callbacks, passing each the same texture.
 
 <p>
 Please be aware that <code>BitmapFactory#decodeStream(InputStream)</code> is a
 comparatively expensive operation: it can take hundreds of milliseconds
 and use several megabytes of temporary RAM. GVRF includes a throttler to
 keep the total load manageable - but
 <a href="../../org/gearvrf/GVRContext.html#loadCompressedTexture-org.gearvrf.GVRAndroidResource.CompressedTextureCallback-org.gearvrf.GVRAndroidResource-"><code>loadCompressedTexture(GVRAndroidResource.CompressedTextureCallback, GVRAndroidResource)</code></a>
 is <em>much</em> faster and lighter-weight: that API simply loads the
 compressed texture into a small amount RAM (which doesn't take very long)
 and does some simple parsing to figure out the parameters to pass
 <code>glCompressedTexImage2D()</code>. The GL hardware does the decoding much
 faster than Android's <code>BitmapFactory</code>!
 
 <p>
 TODO Take a boolean parameter that controls mipmap generation?</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>callback</code> - Before loading, GVRF may call
            <a href="../../org/gearvrf/GVRAndroidResource.CancelableCallback.html#stillWanted-org.gearvrf.GVRAndroidResource-"><code>stillWanted()</code></a> several times (on a background thread) to give
            you a chance to abort a 'stale' load.
 
            Successful loads will call
            <a href="../../org/gearvrf/GVRAndroidResource.Callback.html#loaded-T-org.gearvrf.GVRAndroidResource-"><code>loaded()</code></a> on the GL thread;
 
            any errors will call
            <a href="../../org/gearvrf/GVRAndroidResource.Callback.html#failed-java.lang.Throwable-org.gearvrf.GVRAndroidResource-"><code>failed()</code></a>, with no promises about threading.
 
            <p>
            This method uses a throttler to avoid overloading the system.
            If the throttler has threads available, it will run this
            request immediately. Otherwise, it will enqueue the request,
            and call
            <a href="../../org/gearvrf/GVRAndroidResource.CancelableCallback.html#stillWanted-org.gearvrf.GVRAndroidResource-"><code>stillWanted()</code></a> at least once (on a background thread) to give
            you a chance to abort a 'stale' load.</dd>
<dd><code>resource</code> - Basically, a stream containing a bitmapped image. The
            <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> class has six constructors to
            handle a wide variety of Android resource types. Taking a
            <code>GVRAndroidResource</code> here eliminates six overloads.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If you 'abuse' request consolidation by passing the same
             <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> descriptor to multiple load calls.
             <p>
             It's fairly common for multiple scene objects to use the same
             texture or the same mesh. Thus, if you try to load, say,
             <code>R.raw.whatever</code> while you already have a pending
             request for <code>R.raw.whatever</code>, it will only be loaded
             once; the same resource will be used to satisfy both (all)
             requests. This "consolidation" uses
             <a href="../../org/gearvrf/GVRAndroidResource.html#equals-java.lang.Object-"><code>GVRAndroidResource.equals(Object)</code></a>, <em>not</em>
             <code>==</code> (aka "reference equality"): The problem with using
             the same resource descriptor is that if requests can't be
             consolidated (because the later one(s) came in after the
             earlier one(s) had already completed) the resource will be
             reloaded ... but the original descriptor will have been
             closed.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6.1</dd>
</dl>
</li>
</ul>
<a name="loadBitmapTexture-org.gearvrf.GVRAndroidResource.BitmapTextureCallback-org.gearvrf.GVRAndroidResource-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadBitmapTexture</h4>
<pre>public&nbsp;void&nbsp;loadBitmapTexture(<a href="../../org/gearvrf/GVRAndroidResource.BitmapTextureCallback.html" title="interface in org.gearvrf">GVRAndroidResource.BitmapTextureCallback</a>&nbsp;callback,
                              <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource,
                              int&nbsp;priority)
                       throws java.lang.IllegalArgumentException</pre>
<div class="block">Load a bitmap, asynchronously, with an explicit priority.
 
 Because it is asynchronous, this method <em>is</em> a bit harder to use
 than <a href="../../org/gearvrf/GVRContext.html#loadTexture-java.lang.String-"><code>loadTexture(String)</code></a>, but it moves a large amount of work
 (in <code>BitmapFactory#decodeStream(InputStream)</code> from the GL thread to
 a background thread. Since you <em>can</em> create a
 <a href="../../org/gearvrf/GVRSceneObject.html" title="class in org.gearvrf"><code>GVRSceneObject</code></a> without a mesh and texture - and set them later -
 using the asynchronous API can improve startup speed and/or reduce frame
 misses, where an <a href="../../org/gearvrf/GVRScript.html#onStep--"><code>onStep()</code></a> takes too long.
 
 <p>
 This API will 'consolidate' requests: If you request a texture like
 <code>R.raw.wood_grain</code> and then - before it has loaded - issue another
 request for <code>R.raw.wood_grain</code>, GVRF will only read the bitmap file
 once; only create a single <a href="../../org/gearvrf/GVRTexture.html" title="class in org.gearvrf"><code>GVRTexture</code></a>; and then call both
 callbacks, passing each the same texture.
 
 <p>
 Please be aware that <code>BitmapFactory#decodeStream(InputStream)</code> is a
 comparatively expensive operation: it can take hundreds of milliseconds
 and use several megabytes of temporary RAM. GVRF includes a throttler to
 keep the total load manageable - but
 <a href="../../org/gearvrf/GVRContext.html#loadCompressedTexture-org.gearvrf.GVRAndroidResource.CompressedTextureCallback-org.gearvrf.GVRAndroidResource-"><code>loadCompressedTexture(GVRAndroidResource.CompressedTextureCallback, GVRAndroidResource)</code></a>
 is <em>much</em> faster and lighter-weight: that API simply loads the
 compressed texture into a small amount RAM (which doesn't take very long)
 and does some simple parsing to figure out the parameters to pass
 <code>glCompressedTexImage2D()</code>. The GL hardware does the decoding much
 faster than Android's <code>BitmapFactory</code>!</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>callback</code> - Before loading, GVRF may call
            <a href="../../org/gearvrf/GVRAndroidResource.CancelableCallback.html#stillWanted-org.gearvrf.GVRAndroidResource-"><code>stillWanted()</code></a> several times (on a background thread) to give
            you a chance to abort a 'stale' load.
 
            Successful loads will call
            <a href="../../org/gearvrf/GVRAndroidResource.Callback.html#loaded-T-org.gearvrf.GVRAndroidResource-"><code>loaded()</code></a> on the GL thread;
 
            any errors will call
            <a href="../../org/gearvrf/GVRAndroidResource.Callback.html#failed-java.lang.Throwable-org.gearvrf.GVRAndroidResource-"><code>failed()</code></a>, with no promises about threading.
 
            <p>
            This method uses a throttler to avoid overloading the system.
            If the throttler has threads available, it will run this
            request immediately. Otherwise, it will enqueue the request,
            and call
            <a href="../../org/gearvrf/GVRAndroidResource.CancelableCallback.html#stillWanted-org.gearvrf.GVRAndroidResource-"><code>stillWanted()</code></a> at least once (on a background thread) to give
            you a chance to abort a 'stale' load.</dd>
<dd><code>resource</code> - Basically, a stream containing a bitmapped image. The
            <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> class has six constructors to
            handle a wide variety of Android resource types. Taking a
            <code>GVRAndroidResource</code> here eliminates six overloads.</dd>
<dd><code>priority</code> - This request's priority. Please see the notes on asynchronous
            priorities in the <a href="package-summary.html#async">package
            description</a>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If <code>priority</code> &lt; <a href="../../org/gearvrf/GVRContext.html#LOWEST_PRIORITY"><code>LOWEST_PRIORITY</code></a> or
             &gt; <a href="../../org/gearvrf/GVRContext.html#HIGHEST_PRIORITY"><code>HIGHEST_PRIORITY</code></a>, or either of the
             other parameters is <code>null</code> - or if you 'abuse' request
             consolidation by passing the same <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a>
             descriptor to multiple load calls.
             <p>
             It's fairly common for multiple scene objects to use the same
             texture or the same mesh. Thus, if you try to load, say,
             <code>R.raw.whatever</code> while you already have a pending
             request for <code>R.raw.whatever</code>, it will only be loaded
             once; the same resource will be used to satisfy both (all)
             requests. This "consolidation" uses
             <a href="../../org/gearvrf/GVRAndroidResource.html#equals-java.lang.Object-"><code>GVRAndroidResource.equals(Object)</code></a>, <em>not</em>
             <code>==</code> (aka "reference equality"): The problem with using
             the same resource descriptor is that if requests can't be
             consolidated (because the later one(s) came in after the
             earlier one(s) had already completed) the resource will be
             reloaded ... but the original descriptor will have been
             closed.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6.1</dd>
</dl>
</li>
</ul>
<a name="loadCompressedTexture-org.gearvrf.GVRAndroidResource.CompressedTextureCallback-org.gearvrf.GVRAndroidResource-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadCompressedTexture</h4>
<pre>public&nbsp;void&nbsp;loadCompressedTexture(<a href="../../org/gearvrf/GVRAndroidResource.CompressedTextureCallback.html" title="interface in org.gearvrf">GVRAndroidResource.CompressedTextureCallback</a>&nbsp;callback,
                                  <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource)</pre>
<div class="block">Load a compressed texture, asynchronously.
 
 GVRF currently supports ASTC, ETC2, and KTX formats: applications can add
 new formats by implementing <a href="../../org/gearvrf/asynchronous/GVRCompressedTextureLoader.html" title="class in org.gearvrf.asynchronous"><code>GVRCompressedTextureLoader</code></a>.
 
 <p>
 This method uses the fastest possible rendering. To specify higher
 quality (but slower) rendering, you can use the
 <a href="../../org/gearvrf/GVRContext.html#loadCompressedTexture-org.gearvrf.GVRAndroidResource.CompressedTextureCallback-org.gearvrf.GVRAndroidResource-int-"><code>loadCompressedTexture(GVRAndroidResource.CompressedTextureCallback, GVRAndroidResource, int)</code></a>
 overload.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>callback</code> - Successful loads will call
            <a href="../../org/gearvrf/GVRAndroidResource.Callback.html#loaded-T-org.gearvrf.GVRAndroidResource-"><code>loaded()</code></a> on the GL thread; any errors will call
            <a href="../../org/gearvrf/GVRAndroidResource.Callback.html#failed-java.lang.Throwable-org.gearvrf.GVRAndroidResource-"><code>failed()</code></a>, with no promises about threading.</dd>
<dd><code>resource</code> - Basically, a stream containing a compressed texture. The
            <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> class has six constructors to
            handle a wide variety of Android resource types. Taking a
            <code>GVRAndroidResource</code> here eliminates six overloads.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If you 'abuse' request consolidation by passing the same
             <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> descriptor to multiple load calls.
             <p>
             It's fairly common for multiple scene objects to use the same
             texture or the same mesh. Thus, if you try to load, say,
             <code>R.raw.whatever</code> while you already have a pending
             request for <code>R.raw.whatever</code>, it will only be loaded
             once; the same resource will be used to satisfy both (all)
             requests. This "consolidation" uses
             <a href="../../org/gearvrf/GVRAndroidResource.html#equals-java.lang.Object-"><code>GVRAndroidResource.equals(Object)</code></a>, <em>not</em>
             <code>==</code> (aka "reference equality"): The problem with using
             the same resource descriptor is that if requests can't be
             consolidated (because the later one(s) came in after the
             earlier one(s) had already completed) the resource will be
             reloaded ... but the original descriptor will have been
             closed.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6.1</dd>
</dl>
</li>
</ul>
<a name="loadCompressedTexture-org.gearvrf.GVRAndroidResource.CompressedTextureCallback-org.gearvrf.GVRAndroidResource-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadCompressedTexture</h4>
<pre>public&nbsp;void&nbsp;loadCompressedTexture(<a href="../../org/gearvrf/GVRAndroidResource.CompressedTextureCallback.html" title="interface in org.gearvrf">GVRAndroidResource.CompressedTextureCallback</a>&nbsp;callback,
                                  <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource,
                                  int&nbsp;quality)</pre>
<div class="block">Load a compressed texture, asynchronously.
 
 GVRF currently supports ASTC, ETC2, and KTX formats: applications can add
 new formats by implementing <a href="../../org/gearvrf/asynchronous/GVRCompressedTextureLoader.html" title="class in org.gearvrf.asynchronous"><code>GVRCompressedTextureLoader</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>callback</code> - Successful loads will call
            <a href="../../org/gearvrf/GVRAndroidResource.Callback.html#loaded-T-org.gearvrf.GVRAndroidResource-"><code>GVRAndroidResource.Callback.loaded(GVRHybridObject, GVRAndroidResource)</code></a>
            on the GL thread; any errors will call
            <a href="../../org/gearvrf/GVRAndroidResource.Callback.html#failed-java.lang.Throwable-org.gearvrf.GVRAndroidResource-"><code>GVRAndroidResource.Callback.failed(Throwable, GVRAndroidResource)</code></a>
            , with no promises about threading.</dd>
<dd><code>resource</code> - Basically, a stream containing a compressed texture. The
            <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> class has six constructors to
            handle a wide variety of Android resource types. Taking a
            <code>GVRAndroidResource</code> here eliminates six overloads.</dd>
<dd><code>quality</code> - Speed/quality tradeoff: should be one of
            <a href="../../org/gearvrf/asynchronous/GVRCompressedTexture.html#SPEED"><code>GVRCompressedTexture.SPEED</code></a>,
            <a href="../../org/gearvrf/asynchronous/GVRCompressedTexture.html#BALANCED"><code>GVRCompressedTexture.BALANCED</code></a>, or
            <a href="../../org/gearvrf/asynchronous/GVRCompressedTexture.html#QUALITY"><code>GVRCompressedTexture.QUALITY</code></a>, but other values are
            'clamped' to one of the recognized values.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If you 'abuse' request consolidation by passing the same
             <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> descriptor to multiple load calls.
             <p>
             It's fairly common for multiple scene objects to use the same
             texture or the same mesh. Thus, if you try to load, say,
             <code>R.raw.whatever</code> while you already have a pending
             request for <code>R.raw.whatever</code>, it will only be loaded
             once; the same resource will be used to satisfy both (all)
             requests. This "consolidation" uses
             <a href="../../org/gearvrf/GVRAndroidResource.html#equals-java.lang.Object-"><code>GVRAndroidResource.equals(Object)</code></a>, <em>not</em>
             <code>==</code> (aka "reference equality"): The problem with using
             the same resource descriptor is that if requests can't be
             consolidated (because the later one(s) came in after the
             earlier one(s) had already completed) the resource will be
             reloaded ... but the original descriptor will have been
             closed.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6.1</dd>
</dl>
</li>
</ul>
<a name="loadTexture-org.gearvrf.GVRAndroidResource.TextureCallback-org.gearvrf.GVRAndroidResource-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadTexture</h4>
<pre>public&nbsp;void&nbsp;loadTexture(<a href="../../org/gearvrf/GVRAndroidResource.TextureCallback.html" title="interface in org.gearvrf">GVRAndroidResource.TextureCallback</a>&nbsp;callback,
                        <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource)</pre>
<div class="block">A simplified, low-level method that loads a texture asynchronously,
 without making you specify
 <a href="../../org/gearvrf/GVRContext.html#loadBitmapTexture-org.gearvrf.GVRAndroidResource.BitmapTextureCallback-org.gearvrf.GVRAndroidResource-"><code>loadBitmapTexture()</code></a> or
 <a href="../../org/gearvrf/GVRContext.html#loadCompressedTexture-org.gearvrf.GVRAndroidResource.CompressedTextureCallback-org.gearvrf.GVRAndroidResource-"><code>loadCompressedTexture()</code></a>.
 
 This method can detect whether the resource file holds a compressed
 texture (GVRF currently supports ASTC, ETC2, and KTX formats:
 applications can add new formats by implementing
 <a href="../../org/gearvrf/asynchronous/GVRCompressedTextureLoader.html" title="class in org.gearvrf.asynchronous"><code>GVRCompressedTextureLoader</code></a>): if the file is not a compressed
 texture, it is loaded as a normal, bitmapped texture. This format
 detection adds very little to the cost of loading even a compressed
 texture, and it makes your life a lot easier: you can replace, say,
 <code>res/raw/resource.png</code> with <code>res/raw/resource.etc2</code> without
 having to change any code.
 
 <p>
 This method uses a default priority and a default render quality: Use
 <a href="../../org/gearvrf/GVRContext.html#loadTexture-org.gearvrf.GVRAndroidResource.TextureCallback-org.gearvrf.GVRAndroidResource-int-"><code>loadTexture(GVRAndroidResource.TextureCallback, GVRAndroidResource, int)</code></a>
 to specify an explicit priority, and
 <a href="../../org/gearvrf/GVRContext.html#loadTexture-org.gearvrf.GVRAndroidResource.TextureCallback-org.gearvrf.GVRAndroidResource-int-int-"><code>loadTexture(GVRAndroidResource.TextureCallback, GVRAndroidResource, int, int)</code></a>
 to specify an explicit quality.
 
 <p>
 We will continue to support the <code>loadBitmapTexture()</code> and
 <code>loadCompressedTexture()</code> APIs for at least a little while: We
 haven't yet decided whether to deprecate them or not.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>callback</code> - Before loading, GVRF may call
            <a href="../../org/gearvrf/GVRAndroidResource.CancelableCallback.html#stillWanted-org.gearvrf.GVRAndroidResource-"><code>stillWanted()</code></a> several times (on a background thread) to give
            you a chance to abort a 'stale' load.
 
            Successful loads will call
            <a href="../../org/gearvrf/GVRAndroidResource.Callback.html#loaded-T-org.gearvrf.GVRAndroidResource-"><code>loaded()</code></a> on the GL thread;
 
            any errors will call
            <a href="../../org/gearvrf/GVRAndroidResource.Callback.html#failed-java.lang.Throwable-org.gearvrf.GVRAndroidResource-"><code>failed()</code></a>, with no promises about threading.
 
            <p>
            This method uses a throttler to avoid overloading the system.
            If the throttler has threads available, it will run this
            request immediately. Otherwise, it will enqueue the request,
            and call
            <a href="../../org/gearvrf/GVRAndroidResource.CancelableCallback.html#stillWanted-org.gearvrf.GVRAndroidResource-"><code>stillWanted()</code></a> at least once (on a background thread) to give
            you a chance to abort a 'stale' load.
 
            <p>
            Use <a href="../../org/gearvrf/GVRContext.html#loadFutureTexture-org.gearvrf.GVRAndroidResource-"><code>loadFutureTexture(GVRAndroidResource)</code></a> to avoid
            having to implement a callback.</dd>
<dd><code>resource</code> - Basically, a stream containing a texture file. The
            <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> class has six constructors to
            handle a wide variety of Android resource types. Taking a
            <code>GVRAndroidResource</code> here eliminates six overloads.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If you 'abuse' request consolidation by passing the same
             <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> descriptor to multiple load calls.
             <p>
             It's fairly common for multiple scene objects to use the same
             texture or the same mesh. Thus, if you try to load, say,
             <code>R.raw.whatever</code> while you already have a pending
             request for <code>R.raw.whatever</code>, it will only be loaded
             once; the same resource will be used to satisfy both (all)
             requests. This "consolidation" uses
             <a href="../../org/gearvrf/GVRAndroidResource.html#equals-java.lang.Object-"><code>GVRAndroidResource.equals(Object)</code></a>, <em>not</em>
             <code>==</code> (aka "reference equality"): The problem with using
             the same resource descriptor is that if requests can't be
             consolidated (because the later one(s) came in after the
             earlier one(s) had already completed) the resource will be
             reloaded ... but the original descriptor will have been
             closed.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6.7</dd>
</dl>
</li>
</ul>
<a name="loadTexture-org.gearvrf.GVRAndroidResource.TextureCallback-org.gearvrf.GVRAndroidResource-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadTexture</h4>
<pre>public&nbsp;void&nbsp;loadTexture(<a href="../../org/gearvrf/GVRAndroidResource.TextureCallback.html" title="interface in org.gearvrf">GVRAndroidResource.TextureCallback</a>&nbsp;callback,
                        <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource,
                        int&nbsp;priority)</pre>
<div class="block">A simplified, low-level method that loads a texture asynchronously,
 without making you specify
 <a href="../../org/gearvrf/GVRContext.html#loadBitmapTexture-org.gearvrf.GVRAndroidResource.BitmapTextureCallback-org.gearvrf.GVRAndroidResource-"><code>loadBitmapTexture()</code></a> or
 <a href="../../org/gearvrf/GVRContext.html#loadCompressedTexture-org.gearvrf.GVRAndroidResource.CompressedTextureCallback-org.gearvrf.GVRAndroidResource-"><code>loadCompressedTexture()</code></a>.
 
 This method can detect whether the resource file holds a compressed
 texture (GVRF currently supports ASTC, ETC2, and KTX formats:
 applications can add new formats by implementing
 <a href="../../org/gearvrf/asynchronous/GVRCompressedTextureLoader.html" title="class in org.gearvrf.asynchronous"><code>GVRCompressedTextureLoader</code></a>): if the file is not a compressed
 texture, it is loaded as a normal, bitmapped texture. This format
 detection adds very little to the cost of loading even a compressed
 texture, and it makes your life a lot easier: you can replace, say,
 <code>res/raw/resource.png</code> with <code>res/raw/resource.etc2</code> without
 having to change any code.
 
 <p>
 This method uses a default render quality: Use
 <a href="../../org/gearvrf/GVRContext.html#loadTexture-org.gearvrf.GVRAndroidResource.TextureCallback-org.gearvrf.GVRAndroidResource-int-int-"><code>loadTexture(GVRAndroidResource.TextureCallback, GVRAndroidResource, int, int)</code></a>
 to specify an explicit quality.
 
 <p>
 We will continue to support the <code>loadBitmapTexture()</code> and
 <code>loadCompressedTexture()</code> APIs for at least a little while: We
 haven't yet decided whether to deprecate them or not.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>callback</code> - Before loading, GVRF may call
            <a href="../../org/gearvrf/GVRAndroidResource.CancelableCallback.html#stillWanted-org.gearvrf.GVRAndroidResource-"><code>stillWanted()</code></a> several times (on a background thread) to give
            you a chance to abort a 'stale' load.
 
            Successful loads will call
            <a href="../../org/gearvrf/GVRAndroidResource.Callback.html#loaded-T-org.gearvrf.GVRAndroidResource-"><code>loaded()</code></a> on the GL thread;
 
            any errors will call
            <a href="../../org/gearvrf/GVRAndroidResource.Callback.html#failed-java.lang.Throwable-org.gearvrf.GVRAndroidResource-"><code>failed()</code></a>, with no promises about threading.
 
            <p>
            This method uses a throttler to avoid overloading the system.
            If the throttler has threads available, it will run this
            request immediately. Otherwise, it will enqueue the request,
            and call
            <a href="../../org/gearvrf/GVRAndroidResource.CancelableCallback.html#stillWanted-org.gearvrf.GVRAndroidResource-"><code>stillWanted()</code></a> at least once (on a background thread) to give
            you a chance to abort a 'stale' load.
 
            <p>
            Use <a href="../../org/gearvrf/GVRContext.html#loadFutureTexture-org.gearvrf.GVRAndroidResource-"><code>loadFutureTexture(GVRAndroidResource)</code></a> to avoid
            having to implement a callback.</dd>
<dd><code>resource</code> - Basically, a stream containing a texture file. The
            <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> class has six constructors to
            handle a wide variety of Android resource types. Taking a
            <code>GVRAndroidResource</code> here eliminates six overloads.</dd>
<dd><code>priority</code> - This request's priority. Please see the notes on asynchronous
            priorities in the <a href="package-summary.html#async">package
            description</a>. Also, please note priorities only apply to
            uncompressed textures (standard Android bitmap files, which
            can take hundreds of milliseconds to load): compressed
            textures load so quickly that they are not run through the
            request scheduler.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If you 'abuse' request consolidation by passing the same
             <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> descriptor to multiple load calls.
             <p>
             It's fairly common for multiple scene objects to use the same
             texture or the same mesh. Thus, if you try to load, say,
             <code>R.raw.whatever</code> while you already have a pending
             request for <code>R.raw.whatever</code>, it will only be loaded
             once; the same resource will be used to satisfy both (all)
             requests. This "consolidation" uses
             <a href="../../org/gearvrf/GVRAndroidResource.html#equals-java.lang.Object-"><code>GVRAndroidResource.equals(Object)</code></a>, <em>not</em>
             <code>==</code> (aka "reference equality"): The problem with using
             the same resource descriptor is that if requests can't be
             consolidated (because the later one(s) came in after the
             earlier one(s) had already completed) the resource will be
             reloaded ... but the original descriptor will have been
             closed.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6.7</dd>
</dl>
</li>
</ul>
<a name="loadTexture-org.gearvrf.GVRAndroidResource.TextureCallback-org.gearvrf.GVRAndroidResource-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadTexture</h4>
<pre>public&nbsp;void&nbsp;loadTexture(<a href="../../org/gearvrf/GVRAndroidResource.TextureCallback.html" title="interface in org.gearvrf">GVRAndroidResource.TextureCallback</a>&nbsp;callback,
                        <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource,
                        int&nbsp;priority,
                        int&nbsp;quality)</pre>
<div class="block">A simplified, low-level method that loads a texture asynchronously,
 without making you specify
 <a href="../../org/gearvrf/GVRContext.html#loadBitmapTexture-org.gearvrf.GVRAndroidResource.BitmapTextureCallback-org.gearvrf.GVRAndroidResource-"><code>loadBitmapTexture()</code></a> or
 <a href="../../org/gearvrf/GVRContext.html#loadCompressedTexture-org.gearvrf.GVRAndroidResource.CompressedTextureCallback-org.gearvrf.GVRAndroidResource-"><code>loadCompressedTexture()</code></a>.
 
 This method can detect whether the resource file holds a compressed
 texture (GVRF currently supports ASTC, ETC2, and KTX formats:
 applications can add new formats by implementing
 <a href="../../org/gearvrf/asynchronous/GVRCompressedTextureLoader.html" title="class in org.gearvrf.asynchronous"><code>GVRCompressedTextureLoader</code></a>): if the file is not a compressed
 texture, it is loaded as a normal, bitmapped texture. This format
 detection adds very little to the cost of loading even a compressed
 texture, and it makes your life a lot easier: you can replace, say,
 <code>res/raw/resource.png</code> with <code>res/raw/resource.etc2</code> without
 having to change any code.
 
 <p>
 We will continue to support the <code>loadBitmapTexture()</code> and
 <code>loadCompressedTexture()</code> APIs for at least a little while: We
 haven't yet decided whether to deprecate them or not.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>callback</code> - Before loading, GVRF may call
            <a href="../../org/gearvrf/GVRAndroidResource.CancelableCallback.html#stillWanted-org.gearvrf.GVRAndroidResource-"><code>stillWanted()</code></a> several times (on a background thread) to give
            you a chance to abort a 'stale' load.
 
            Successful loads will call
            <a href="../../org/gearvrf/GVRAndroidResource.Callback.html#loaded-T-org.gearvrf.GVRAndroidResource-"><code>loaded()</code></a> on the GL thread;
 
            any errors will call
            <a href="../../org/gearvrf/GVRAndroidResource.Callback.html#failed-java.lang.Throwable-org.gearvrf.GVRAndroidResource-"><code>failed()</code></a>, with no promises about threading.
 
            <p>
            This method uses a throttler to avoid overloading the system.
            If the throttler has threads available, it will run this
            request immediately. Otherwise, it will enqueue the request,
            and call
            <a href="../../org/gearvrf/GVRAndroidResource.CancelableCallback.html#stillWanted-org.gearvrf.GVRAndroidResource-"><code>stillWanted()</code></a> at least once (on a background thread) to give
            you a chance to abort a 'stale' load.
 
            <p>
            Use <a href="../../org/gearvrf/GVRContext.html#loadFutureTexture-org.gearvrf.GVRAndroidResource-"><code>loadFutureTexture(GVRAndroidResource)</code></a> to avoid
            having to implement a callback.</dd>
<dd><code>resource</code> - Basically, a stream containing a texture file. The
            <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> class has six constructors to
            handle a wide variety of Android resource types. Taking a
            <code>GVRAndroidResource</code> here eliminates six overloads.</dd>
<dd><code>priority</code> - This request's priority. Please see the notes on asynchronous
            priorities in the <a href="package-summary.html#async">package
            description</a>. Also, please note priorities only apply to
            uncompressed textures (standard Android bitmap files, which
            can take hundreds of milliseconds to load): compressed
            textures load so quickly that they are not run through the
            request scheduler.</dd>
<dd><code>quality</code> - The compressed texture <a href="../../org/gearvrf/asynchronous/GVRCompressedTexture.html#mQuality"><code>quality</code></a> parameter: should be one of
            <a href="../../org/gearvrf/asynchronous/GVRCompressedTexture.html#SPEED"><code>GVRCompressedTexture.SPEED</code></a>,
            <a href="../../org/gearvrf/asynchronous/GVRCompressedTexture.html#BALANCED"><code>GVRCompressedTexture.BALANCED</code></a>, or
            <a href="../../org/gearvrf/asynchronous/GVRCompressedTexture.html#QUALITY"><code>GVRCompressedTexture.QUALITY</code></a>, but other values are
            'clamped' to one of the recognized values. Please note that
            this (currently) only applies to compressed textures; normal
            <a href="../../org/gearvrf/GVRBitmapTexture.html" title="class in org.gearvrf">bitmapped textures</a> don't take a
            quality parameter.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If you 'abuse' request consolidation by passing the same
             <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> descriptor to multiple load calls.
             <p>
             It's fairly common for multiple scene objects to use the same
             texture or the same mesh. Thus, if you try to load, say,
             <code>R.raw.whatever</code> while you already have a pending
             request for <code>R.raw.whatever</code>, it will only be loaded
             once; the same resource will be used to satisfy both (all)
             requests. This "consolidation" uses
             <a href="../../org/gearvrf/GVRAndroidResource.html#equals-java.lang.Object-"><code>GVRAndroidResource.equals(Object)</code></a>, <em>not</em>
             <code>==</code> (aka "reference equality"): The problem with using
             the same resource descriptor is that if requests can't be
             consolidated (because the later one(s) came in after the
             earlier one(s) had already completed) the resource will be
             reloaded ... but the original descriptor will have been
             closed.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6.7</dd>
</dl>
</li>
</ul>
<a name="loadFutureTexture-org.gearvrf.GVRAndroidResource-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadFutureTexture</h4>
<pre>public&nbsp;java.util.concurrent.Future&lt;<a href="../../org/gearvrf/GVRTexture.html" title="class in org.gearvrf">GVRTexture</a>&gt;&nbsp;loadFutureTexture(<a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource)</pre>
<div class="block">Simple, high-level method to load a texture asynchronously, for use with
 <a href="../../org/gearvrf/GVRShaders.html#setMainTexture-java.util.concurrent.Future-"><code>GVRShaders.setMainTexture(Future)</code></a> and
 <a href="../../org/gearvrf/GVRShaders.html#setTexture-java.lang.String-java.util.concurrent.Future-"><code>GVRShaders.setTexture(String, Future)</code></a>.
 
 This method uses a default priority and a default render quality: use
 <a href="../../org/gearvrf/GVRContext.html#loadFutureTexture-org.gearvrf.GVRAndroidResource-int-"><code>loadFutureTexture(GVRAndroidResource, int)</code></a> to specify a priority
 or <a href="../../org/gearvrf/GVRContext.html#loadFutureTexture-org.gearvrf.GVRAndroidResource-int-int-"><code>loadFutureTexture(GVRAndroidResource, int, int)</code></a> to specify a
 priority and render quality.
 
 <p>
 This method is significantly easier to use than
 <a href="../../org/gearvrf/GVRContext.html#loadTexture-org.gearvrf.GVRAndroidResource.TextureCallback-org.gearvrf.GVRAndroidResource-"><code>loadTexture(GVRAndroidResource.TextureCallback, GVRAndroidResource)</code></a>
 : you don't have to implement a callback; you don't have to pay attention
 to the low-level details of
 <a href="../../org/gearvrf/GVRSceneObject.html#attachRenderData-org.gearvrf.GVRRenderData-">attaching</a> a
 <a href="../../org/gearvrf/GVRRenderData.html" title="class in org.gearvrf"><code>GVRRenderData</code></a> to your scene object. What's more, you don't even
 lose any functionality: <code>Future.cancel(boolean)</code> lets you cancel a
 'stale' request, just like
 <a href="../../org/gearvrf/GVRAndroidResource.CancelableCallback.html#stillWanted-org.gearvrf.GVRAndroidResource-"><code>stillWanted()</code></a> does. The flip side, of course, is that it <em>is</em> a
 bit more expensive: methods like
 <a href="../../org/gearvrf/GVRMaterial.html#setMainTexture-java.util.concurrent.Future-"><code>GVRMaterial.setMainTexture(Future)</code></a> use an extra thread from the
 thread pool to wait for the blocking <code>Future.get()</code> call. For
 modest numbers of loads, this overhead is acceptable - but thread
 creation is not free, and if your <a href="../../org/gearvrf/GVRScript.html#onInit-org.gearvrf.GVRContext-"><code>onInit()</code></a> method fires of dozens of future loads, you may well see an
 impact.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>resource</code> - Basically, a stream containing a texture file. The
            <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> class has six constructors to
            handle a wide variety of Android resource types. Taking a
            <code>GVRAndroidResource</code> here eliminates six overloads.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <code>Future</code> that you can pass to methods like
         <a href="../../org/gearvrf/GVRShaders.html#setMainTexture-java.util.concurrent.Future-"><code>GVRShaders.setMainTexture(Future)</code></a></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If you 'abuse' request consolidation by passing the same
             <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> descriptor to multiple load calls.
             <p>
             It's fairly common for multiple scene objects to use the same
             texture or the same mesh. Thus, if you try to load, say,
             <code>R.raw.whatever</code> while you already have a pending
             request for <code>R.raw.whatever</code>, it will only be loaded
             once; the same resource will be used to satisfy both (all)
             requests. This "consolidation" uses
             <a href="../../org/gearvrf/GVRAndroidResource.html#equals-java.lang.Object-"><code>GVRAndroidResource.equals(Object)</code></a>, <em>not</em>
             <code>==</code> (aka "reference equality"): The problem with using
             the same resource descriptor is that if requests can't be
             consolidated (because the later one(s) came in after the
             earlier one(s) had already completed) the resource will be
             reloaded ... but the original descriptor will have been
             closed.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6.7</dd>
</dl>
</li>
</ul>
<a name="loadFutureTexture-org.gearvrf.GVRAndroidResource-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadFutureTexture</h4>
<pre>public&nbsp;java.util.concurrent.Future&lt;<a href="../../org/gearvrf/GVRTexture.html" title="class in org.gearvrf">GVRTexture</a>&gt;&nbsp;loadFutureTexture(<a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource,
                                                                 int&nbsp;priority)</pre>
<div class="block">Simple, high-level method to load a texture asynchronously, for use with
 <a href="../../org/gearvrf/GVRShaders.html#setMainTexture-java.util.concurrent.Future-"><code>GVRShaders.setMainTexture(Future)</code></a> and
 <a href="../../org/gearvrf/GVRShaders.html#setTexture-java.lang.String-java.util.concurrent.Future-"><code>GVRShaders.setTexture(String, Future)</code></a>.
 
 This method uses a default render quality:
 <a href="../../org/gearvrf/GVRContext.html#loadFutureTexture-org.gearvrf.GVRAndroidResource-int-int-"><code>loadFutureTexture(GVRAndroidResource, int, int)</code></a> to specify
 render quality.
 
 <p>
 This method is significantly easier to use than
 #loadTexture(GVRAndroidResource.TextureCallback, GVRAndroidResource, int)
 : you don't have to implement a callback; you don't have to pay attention
 to the low-level details of
{@linkplain GVRSceneObject#attachRenderData(GVRRenderData) attaching} a
 {@link GVRRenderData} to your scene object. What's more, you don't even
 lose any functionality: {@link Future#cancel(boolean)} lets you cancel a
 'stale' request, just like
 {@link GVRAndroidResource.CancelableCallback#stillWanted(GVRAndroidResource)
 stillWanted()} does. The flip side, of course, is that it <em>is</em> a
 bit more expensive: methods like
 {@link GVRMaterial#setMainTexture(Future)} use an extra thread from the
 thread pool to wait for the blocking {@link Future#get()} call. For
 modest numbers of loads, this overhead is acceptable - but thread
 creation is not free, and if your {@link GVRScript#onInit(GVRContext)
 onInit()} method fires of dozens of future loads, you may well see an
 impact.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>resource</code> - Basically, a stream containing a texture file. The
            <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> class has six constructors to
            handle a wide variety of Android resource types. Taking a
            <code>GVRAndroidResource</code> here eliminates six overloads.</dd>
<dd><code>priority</code> - This request's priority. Please see the notes on asynchronous
            priorities in the <a href="package-summary.html#async">package
            description</a>. Also, please note priorities only apply to
            uncompressed textures (standard Android bitmap files, which
            can take hundreds of milliseconds to load): compressed
            textures load so quickly that they are not run through the
            request scheduler.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <code>Future</code> that you can pass to methods like
         <a href="../../org/gearvrf/GVRShaders.html#setMainTexture-java.util.concurrent.Future-"><code>GVRShaders.setMainTexture(Future)</code></a></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If you 'abuse' request consolidation by passing the same
             <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> descriptor to multiple load calls.
             <p>
             It's fairly common for multiple scene objects to use the same
             texture or the same mesh. Thus, if you try to load, say,
             <code>R.raw.whatever</code> while you already have a pending
             request for <code>R.raw.whatever</code>, it will only be loaded
             once; the same resource will be used to satisfy both (all)
             requests. This "consolidation" uses
             <a href="../../org/gearvrf/GVRAndroidResource.html#equals-java.lang.Object-"><code>GVRAndroidResource.equals(Object)</code></a>, <em>not</em>
             <code>==</code> (aka "reference equality"): The problem with using
             the same resource descriptor is that if requests can't be
             consolidated (because the later one(s) came in after the
             earlier one(s) had already completed) the resource will be
             reloaded ... but the original descriptor will have been
             closed.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6.7</dd>
</dl>
</li>
</ul>
<a name="loadFutureTexture-org.gearvrf.GVRAndroidResource-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadFutureTexture</h4>
<pre>public&nbsp;java.util.concurrent.Future&lt;<a href="../../org/gearvrf/GVRTexture.html" title="class in org.gearvrf">GVRTexture</a>&gt;&nbsp;loadFutureTexture(<a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource,
                                                                 int&nbsp;priority,
                                                                 int&nbsp;quality)</pre>
<div class="block">Simple, high-level method to load a texture asynchronously, for use with
 <a href="../../org/gearvrf/GVRShaders.html#setMainTexture-java.util.concurrent.Future-"><code>GVRShaders.setMainTexture(Future)</code></a> and
 <a href="../../org/gearvrf/GVRShaders.html#setTexture-java.lang.String-java.util.concurrent.Future-"><code>GVRShaders.setTexture(String, Future)</code></a>.
 
 
 <p>
 This method is significantly easier to use than
 #loadTexture(GVRAndroidResource.TextureCallback, GVRAndroidResource, int, int)
 : you don't have to implement a callback; you don't have to pay attention
 to the low-level details of
{@linkplain GVRSceneObject#attachRenderData(GVRRenderData) attaching} a
 {@link GVRRenderData} to your scene object. What's more, you don't even
 lose any functionality: {@link Future#cancel(boolean)} lets you cancel a
 'stale' request, just like
 {@link GVRAndroidResource.CancelableCallback#stillWanted(GVRAndroidResource)
 stillWanted()} does. The flip side, of course, is that it <em>is</em> a
 bit more expensive: methods like
 {@link GVRMaterial#setMainTexture(Future)} use an extra thread from the
 thread pool to wait for the blocking {@link Future#get()} call. For
 modest numbers of loads, this overhead is acceptable - but thread
 creation is not free, and if your {@link GVRScript#onInit(GVRContext)
 onInit()} method fires of dozens of future loads, you may well see an
 impact.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>resource</code> - Basically, a stream containing a texture file. The
            <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> class has six constructors to
            handle a wide variety of Android resource types. Taking a
            <code>GVRAndroidResource</code> here eliminates six overloads.</dd>
<dd><code>priority</code> - This request's priority. Please see the notes on asynchronous
            priorities in the <a href="package-summary.html#async">package
            description</a>. Also, please note priorities only apply to
            uncompressed textures (standard Android bitmap files, which
            can take hundreds of milliseconds to load): compressed
            textures load so quickly that they are not run through the
            request scheduler.</dd>
<dd><code>quality</code> - The compressed texture <a href="../../org/gearvrf/asynchronous/GVRCompressedTexture.html#mQuality"><code>quality</code></a> parameter: should be one of
            <a href="../../org/gearvrf/asynchronous/GVRCompressedTexture.html#SPEED"><code>GVRCompressedTexture.SPEED</code></a>,
            <a href="../../org/gearvrf/asynchronous/GVRCompressedTexture.html#BALANCED"><code>GVRCompressedTexture.BALANCED</code></a>, or
            <a href="../../org/gearvrf/asynchronous/GVRCompressedTexture.html#QUALITY"><code>GVRCompressedTexture.QUALITY</code></a>, but other values are
            'clamped' to one of the recognized values. Please note that
            this (currently) only applies to compressed textures; normal
            <a href="../../org/gearvrf/GVRBitmapTexture.html" title="class in org.gearvrf">bitmapped textures</a> don't take a
            quality parameter.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <code>Future</code> that you can pass to methods like
         <a href="../../org/gearvrf/GVRShaders.html#setMainTexture-java.util.concurrent.Future-"><code>GVRShaders.setMainTexture(Future)</code></a></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If you 'abuse' request consolidation by passing the same
             <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> descriptor to multiple load calls.
             <p>
             It's fairly common for multiple scene objects to use the same
             texture or the same mesh. Thus, if you try to load, say,
             <code>R.raw.whatever</code> while you already have a pending
             request for <code>R.raw.whatever</code>, it will only be loaded
             once; the same resource will be used to satisfy both (all)
             requests. This "consolidation" uses
             <a href="../../org/gearvrf/GVRAndroidResource.html#equals-java.lang.Object-"><code>GVRAndroidResource.equals(Object)</code></a>, <em>not</em>
             <code>==</code> (aka "reference equality"): The problem with using
             the same resource descriptor is that if requests can't be
             consolidated (because the later one(s) came in after the
             earlier one(s) had already completed) the resource will be
             reloaded ... but the original descriptor will have been
             closed.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6.7</dd>
</dl>
</li>
</ul>
<a name="loadFutureCubemapTexture-org.gearvrf.GVRAndroidResource-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadFutureCubemapTexture</h4>
<pre>public&nbsp;java.util.concurrent.Future&lt;<a href="../../org/gearvrf/GVRTexture.html" title="class in org.gearvrf">GVRTexture</a>&gt;&nbsp;loadFutureCubemapTexture(<a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf">GVRAndroidResource</a>&nbsp;resource)</pre>
<div class="block">Simple, high-level method to load a cube map texture asynchronously, for
 use with <a href="../../org/gearvrf/GVRShaders.html#setMainTexture-java.util.concurrent.Future-"><code>GVRShaders.setMainTexture(Future)</code></a> and
 <a href="../../org/gearvrf/GVRShaders.html#setTexture-java.lang.String-java.util.concurrent.Future-"><code>GVRShaders.setTexture(String, Future)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>resource</code> - A steam containing a zip file which contains six bitmaps. The
            six bitmaps correspond to +x, -x, +y, -y, +z, and -z faces of
            the cube map texture respectively. The default names of the
            six images are "posx.png", "negx.png", "posy.png", "negx.png",
            "posz.png", and "negz.png", which can be changed by calling
            <a href="../../org/gearvrf/GVRCubemapTexture.html#setFaceNames-java.lang.String:A-"><code>GVRCubemapTexture.setFaceNames(String[])</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <code>Future</code> that you can pass to methods like
         <a href="../../org/gearvrf/GVRShaders.html#setMainTexture-java.util.concurrent.Future-"><code>GVRShaders.setMainTexture(Future)</code></a></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If you 'abuse' request consolidation by passing the same
             <a href="../../org/gearvrf/GVRAndroidResource.html" title="class in org.gearvrf"><code>GVRAndroidResource</code></a> descriptor to multiple load calls.
             <p>
             It's fairly common for multiple scene objects to use the same
             texture or the same mesh. Thus, if you try to load, say,
             <code>R.raw.whatever</code> while you already have a pending
             request for <code>R.raw.whatever</code>, it will only be loaded
             once; the same resource will be used to satisfy both (all)
             requests. This "consolidation" uses
             <a href="../../org/gearvrf/GVRAndroidResource.html#equals-java.lang.Object-"><code>GVRAndroidResource.equals(Object)</code></a>, <em>not</em>
             <code>==</code> (aka "reference equality"): The problem with using
             the same resource descriptor is that if requests can't be
             consolidated (because the later one(s) came in after the
             earlier one(s) had already completed) the resource will be
             reloaded ... but the original descriptor will have been
             closed.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6.9</dd>
</dl>
</li>
</ul>
<a name="getMainScene--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMainScene</h4>
<pre>public abstract&nbsp;<a href="../../org/gearvrf/GVRScene.html" title="class in org.gearvrf">GVRScene</a>&nbsp;getMainScene()</pre>
<div class="block">Get the current <a href="../../org/gearvrf/GVRScene.html" title="class in org.gearvrf"><code>GVRScene</code></a>, which contains the scene graph (a
 hierarchy of <a href="../../org/gearvrf/GVRSceneObject.html" title="class in org.gearvrf">scene objects</a>) and the
 <a href="../../org/gearvrf/GVRCameraRig.html" title="class in org.gearvrf">camera rig</a></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="../../org/gearvrf/GVRScene.html" title="class in org.gearvrf"><code>GVRScene</code></a> instance, containing scene and camera
         information</dd>
</dl>
</li>
</ul>
<a name="setMainScene-org.gearvrf.GVRScene-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setMainScene</h4>
<pre>public abstract&nbsp;void&nbsp;setMainScene(<a href="../../org/gearvrf/GVRScene.html" title="class in org.gearvrf">GVRScene</a>&nbsp;scene)</pre>
<div class="block">Set the current <a href="../../org/gearvrf/GVRScene.html" title="class in org.gearvrf"><code>GVRScene</code></a></div>
</li>
</ul>
<a name="getNextMainScene--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNextMainScene</h4>
<pre>public&nbsp;<a href="../../org/gearvrf/GVRScene.html" title="class in org.gearvrf">GVRScene</a>&nbsp;getNextMainScene()</pre>
<div class="block">Returns a <a href="../../org/gearvrf/GVRScene.html" title="class in org.gearvrf"><code>GVRScene</code></a> that you can populate before passing to
 <a href="../../org/gearvrf/GVRContext.html#setMainScene-org.gearvrf.GVRScene-"><code>setMainScene(GVRScene)</code></a>.
 
 Implementation maintains a single element buffer, initialized to
 <code>null</code>. When this method is called, creates a new scene if the
 buffer is <code>null</code>, then returns the buffered scene. If this buffered
 scene is passed to <a href="../../org/gearvrf/GVRContext.html#setMainScene-org.gearvrf.GVRScene-"><code>setMainScene(GVRScene)</code></a>, the buffer is reset
 to <code>null</code>.
 
 <p>
 One use of this is to build your scene graph while the splash screen is
 visible. If you have called <a href="../../org/gearvrf/GVRContext.html#getNextMainScene--">getNextMainScene()</a> (so that the
 next-main-scene buffer is non-<code>null</code> when the splash screen is
 closed) GVRF will automatically switch to the 'pending' main-scene; if
 the buffer is <code>null</code>, GVRF will simply remove the splash screen
 from the main scene object.</div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6.4</dd>
</dl>
</li>
</ul>
<a name="getNextMainScene-java.lang.Runnable-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNextMainScene</h4>
<pre>public abstract&nbsp;<a href="../../org/gearvrf/GVRScene.html" title="class in org.gearvrf">GVRScene</a>&nbsp;getNextMainScene(java.lang.Runnable&nbsp;onSwitchMainScene)</pre>
<div class="block">Returns a <a href="../../org/gearvrf/GVRScene.html" title="class in org.gearvrf"><code>GVRScene</code></a> that you can populate before passing to
 <a href="../../org/gearvrf/GVRContext.html#setMainScene-org.gearvrf.GVRScene-"><code>setMainScene(GVRScene)</code></a>.
 
 Implementation maintains a single element buffer, initialized to
 <code>null</code>. When this method is called, creates a new scene if the
 buffer is <code>null</code>, then returns the buffered scene. If this buffered
 scene is passed to <a href="../../org/gearvrf/GVRContext.html#setMainScene-org.gearvrf.GVRScene-"><code>setMainScene(GVRScene)</code></a>, the buffer is reset
 to <code>null</code>.
 
 <p>
 One use of this is to build your scene graph while the splash screen is
 visible. If you have called <a href="../../org/gearvrf/GVRContext.html#getNextMainScene--">getNextMainScene()</a> (so that the
 next-main-scene buffer is non-<code>null</code> when the splash screen is
 closed) GVRF will automatically switch to the 'pending' main-scene; if
 the buffer is <code>null</code>, GVRF will simply remove the splash screen
 from the main scene object.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onSwitchMainScene</code> - Optional (may be <code>null</code>) <code>Runnable</code>, called when
            this <a href="../../org/gearvrf/GVRScene.html" title="class in org.gearvrf"><code>GVRScene</code></a> becomes the new main scene, whether
            <a href="../../org/gearvrf/GVRContext.html#setMainScene-org.gearvrf.GVRScene-">explicitly</a> or implicitly
            (as, for example, when the splash screen closes). This
            callback lets apps do things like start animations when their
            scene becomes visible, instead of in
            <a href="../../org/gearvrf/GVRScript.html#onInit-org.gearvrf.GVRContext-"><code>onInit()</code></a> when the scene
            objects may be hidden by the splash screen.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6.4</dd>
</dl>
</li>
</ul>
<a name="isKeyDown-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isKeyDown</h4>
<pre>public abstract&nbsp;boolean&nbsp;isKeyDown(int&nbsp;keyCode)</pre>
<div class="block">Is the key pressed?</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>keyCode</code> - An Android key code</dd>
</dl>
</li>
</ul>
<a name="getFrameTime--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFrameTime</h4>
<pre>public abstract&nbsp;float&nbsp;getFrameTime()</pre>
<div class="block">The interval between this frame and the previous frame, in seconds: a
 rough gauge of Frames Per Second.</div>
</li>
</ul>
<a name="runOnGlThread-java.lang.Runnable-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>runOnGlThread</h4>
<pre>public abstract&nbsp;void&nbsp;runOnGlThread(java.lang.Runnable&nbsp;runnable)</pre>
<div class="block">Enqueues a callback to be run in the GL thread.
 
 This is how you take data generated on a background thread (or the main
 (GUI) thread) and pass it to the coprocessor, using calls that must be
 made from the GL thread (aka the "GL context"). The callback queue is
 processed before any registered
 <a href="../../org/gearvrf/GVRContext.html#registerDrawFrameListener-org.gearvrf.GVRDrawFrameListener-">frame
 listeners</a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>runnable</code> - A bit of code that must run on the GL thread</dd>
</dl>
</li>
</ul>
<a name="registerDrawFrameListener-org.gearvrf.GVRDrawFrameListener-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>registerDrawFrameListener</h4>
<pre>public abstract&nbsp;void&nbsp;registerDrawFrameListener(<a href="../../org/gearvrf/GVRDrawFrameListener.html" title="interface in org.gearvrf">GVRDrawFrameListener</a>&nbsp;frameListener)</pre>
<div class="block">Subscribes a <a href="../../org/gearvrf/GVRDrawFrameListener.html" title="interface in org.gearvrf"><code>GVRDrawFrameListener</code></a>.
 
 Each frame listener is called, once per frame, after any pending
 <a href="../../org/gearvrf/GVRContext.html#runOnGlThread-java.lang.Runnable-">GL callbacks</a> and before
 <a href="../../org/gearvrf/GVRScript.html#onStep--"><code>GVRScript.onStep()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>frameListener</code> - A callback that will fire once per frame, until it is
            <a href="../../org/gearvrf/GVRContext.html#unregisterDrawFrameListener-org.gearvrf.GVRDrawFrameListener-">unregistered</a></dd>
</dl>
</li>
</ul>
<a name="unregisterDrawFrameListener-org.gearvrf.GVRDrawFrameListener-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unregisterDrawFrameListener</h4>
<pre>public abstract&nbsp;void&nbsp;unregisterDrawFrameListener(<a href="../../org/gearvrf/GVRDrawFrameListener.html" title="interface in org.gearvrf">GVRDrawFrameListener</a>&nbsp;frameListener)</pre>
<div class="block">Remove a previously-subscribed <a href="../../org/gearvrf/GVRDrawFrameListener.html" title="interface in org.gearvrf"><code>GVRDrawFrameListener</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>frameListener</code> - An instance of a <a href="../../org/gearvrf/GVRDrawFrameListener.html" title="interface in org.gearvrf"><code>GVRDrawFrameListener</code></a> implementation.
            Unsubscribing a listener which is not actually subscribed will
            not throw an exception.</dd>
</dl>
</li>
</ul>
<a name="getMaterialShaderManager--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMaterialShaderManager</h4>
<pre>public&nbsp;<a href="../../org/gearvrf/GVRMaterialShaderManager.html" title="class in org.gearvrf">GVRMaterialShaderManager</a>&nbsp;getMaterialShaderManager()</pre>
<div class="block">The <a href="../../org/gearvrf/GVRMaterialShaderManager.html" title="class in org.gearvrf">object shader manager</a>
 singleton.
 
 Use the shader manager to define custom GL object shaders, which are used
 to render a scene object's surface.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The <a href="../../org/gearvrf/GVRMaterialShaderManager.html" title="class in org.gearvrf">shader manager</a>
         singleton.</dd>
</dl>
</li>
</ul>
<a name="getPostEffectShaderManager--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPostEffectShaderManager</h4>
<pre>public&nbsp;<a href="../../org/gearvrf/GVRPostEffectShaderManager.html" title="class in org.gearvrf">GVRPostEffectShaderManager</a>&nbsp;getPostEffectShaderManager()</pre>
<div class="block">The <a href="../../org/gearvrf/GVRPostEffectShaderManager.html" title="class in org.gearvrf">scene shader manager</a>
 singleton.
 
 Use the shader manager to define custom GL scene shaders, which can be
 inserted into the rendering pipeline to apply image processing effects to
 the rendered scene graph. In classic GL programming, this is often
 referred to as a "post effect."</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The <a href="../../org/gearvrf/GVRPostEffectShaderManager.html" title="class in org.gearvrf">post effect shader
         manager</a> singleton.</dd>
</dl>
</li>
</ul>
<a name="getAnimationEngine--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAnimationEngine</h4>
<pre>public&nbsp;<a href="../../org/gearvrf/animation/GVRAnimationEngine.html" title="class in org.gearvrf.animation">GVRAnimationEngine</a>&nbsp;getAnimationEngine()</pre>
<div class="block">The <a href="../../org/gearvrf/animation/GVRAnimationEngine.html" title="class in org.gearvrf.animation">animation engine</a> singleton.
 
 Use the animation engine to start and stop <a href="../../org/gearvrf/animation/GVRAnimation.html" title="class in org.gearvrf.animation">animations</a>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The <a href="../../org/gearvrf/animation/GVRAnimationEngine.html" title="class in org.gearvrf.animation">animation engine</a> singleton.</dd>
</dl>
</li>
</ul>
<a name="getPeriodicEngine--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPeriodicEngine</h4>
<pre>public&nbsp;<a href="../../org/gearvrf/periodic/GVRPeriodicEngine.html" title="class in org.gearvrf.periodic">GVRPeriodicEngine</a>&nbsp;getPeriodicEngine()</pre>
<div class="block">The <a href="../../org/gearvrf/periodic/GVRPeriodicEngine.html" title="class in org.gearvrf.periodic">periodic engine</a> singleton.
 
 Use the periodic engine to schedule runnables to
 run on the GL thread at a future time.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The <a href="../../org/gearvrf/periodic/GVRPeriodicEngine.html" title="class in org.gearvrf.periodic">periodic engine</a> singleton.</dd>
</dl>
</li>
</ul>
<a name="addResetOnRestartHandler-java.lang.Runnable-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addResetOnRestartHandler</h4>
<pre>public static&nbsp;void&nbsp;addResetOnRestartHandler(java.lang.Runnable&nbsp;handler)</pre>
<div class="block">Register a method that is called every time GVRF creates a new
 <a href="../../org/gearvrf/GVRContext.html" title="class in org.gearvrf"><code>GVRContext</code></a>.
 
 Android apps aren't mapped 1:1 to Linux processes; the system may keep a
 process loaded even after normal complete shutdown, and call Android
 lifecycle methods to reinitialize it. This causes problems for (in
 particular) lazy-created singletons that are tied to a particular
 <code>GVRContext</code>. This method lets you register a handler that will be
 called on restart, which can reset your <code>static</code> variables to the
 compiled-in start state.
 
 <p>
 For example,
 
 <pre>
 
 static YourSingletonClass sInstance;
 static {
     GVRContext.addResetOnRestartHandler(new Runnable() {
 
         &#064;Override
         public void run() {
             sInstance = null;
         }
     });
 }
 
 </pre>
 
 <p>
 GVRF will force an Android garbage collection after running any handlers,
 which will free any remaining native objects from the previous run.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>handler</code> - Callback to run on restart.</dd>
</dl>
</li>
</ul>
<a name="captureScreenCenter-org.gearvrf.GVRScreenshotCallback-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>captureScreenCenter</h4>
<pre>public abstract&nbsp;void&nbsp;captureScreenCenter(<a href="../../org/gearvrf/GVRScreenshotCallback.html" title="interface in org.gearvrf">GVRScreenshotCallback</a>&nbsp;callback)</pre>
<div class="block">Capture a 2D screenshot from the position in the middle of left eye and
 right eye.
 
 The screenshot capture is done asynchronously -- the function does not
 return the result immediately. Instead, it registers a callback function
 and pass the result (when it is available) to the callback function. The
 callback will happen on a background thread: It will probably not be the
 same thread that calls this method, and it will not be either the GUI or
 the GL thread.
 
 Users should not start a <code>captureScreenCenter</code> until previous
 <code>captureScreenCenter</code> callback has returned. Starting a new
 <code>captureScreenCenter</code> before the previous
 <code>captureScreenCenter</code> callback returned may cause out of memory
 error.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>callback</code> - Callback function to process the capture result. It may not be
            <code>null</code>.</dd>
</dl>
</li>
</ul>
<a name="captureScreenLeft-org.gearvrf.GVRScreenshotCallback-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>captureScreenLeft</h4>
<pre>public abstract&nbsp;void&nbsp;captureScreenLeft(<a href="../../org/gearvrf/GVRScreenshotCallback.html" title="interface in org.gearvrf">GVRScreenshotCallback</a>&nbsp;callback)</pre>
<div class="block">Capture a 2D screenshot from the position of left eye.
 
 The screenshot capture is done asynchronously -- the function does not
 return the result immediately. Instead, it registers a callback function
 and pass the result (when it is available) to the callback function. The
 callback will happen on a background thread: It will probably not be the
 same thread that calls this method, and it will not be either the GUI or
 the GL thread.
 
 Users should not start a <code>captureScreenLeft</code> until previous
 <code>captureScreenLeft</code> callback has returned. Starting a new
 <code>captureScreenLeft</code> before the previous <code>captureScreenLeft</code>
 callback returned may cause out of memory error.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>callback</code> - Callback function to process the capture result. It may not be
            <code>null</code>.</dd>
</dl>
</li>
</ul>
<a name="captureScreenRight-org.gearvrf.GVRScreenshotCallback-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>captureScreenRight</h4>
<pre>public abstract&nbsp;void&nbsp;captureScreenRight(<a href="../../org/gearvrf/GVRScreenshotCallback.html" title="interface in org.gearvrf">GVRScreenshotCallback</a>&nbsp;callback)</pre>
<div class="block">Capture a 2D screenshot from the position of right eye.
 
 The screenshot capture is done asynchronously -- the function does not
 return the result immediately. Instead, it registers a callback function
 and pass the result (when it is available) to the callback function. The
 callback will happen on a background thread: It will probably not be the
 same thread that calls this method, and it will not be either the GUI or
 the GL thread.
 
 Users should not start a <code>captureScreenRight</code> until previous
 <code>captureScreenRight</code> callback has returned. Starting a new
 <code>captureScreenRight</code> before the previous <code>captureScreenRight</code>
 callback returned may cause out of memory error.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>callback</code> - Callback function to process the capture result. It may not be
            <code>null</code>.</dd>
</dl>
</li>
</ul>
<a name="captureScreen3D-org.gearvrf.GVRScreenshot3DCallback-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>captureScreen3D</h4>
<pre>public abstract&nbsp;void&nbsp;captureScreen3D(<a href="../../org/gearvrf/GVRScreenshot3DCallback.html" title="interface in org.gearvrf">GVRScreenshot3DCallback</a>&nbsp;callback)</pre>
<div class="block">Capture a 3D screenshot from the position of left eye. The 3D screenshot
 is composed of six images from six directions (i.e. +x, -x, +y, -y, +z,
 and -z).
 
 The screenshot capture is done asynchronously -- the function does not
 return the result immediately. Instead, it registers a callback function
 and pass the result (when it is available) to the callback function. The
 callback will happen on a background thread: It will probably not be the
 same thread that calls this method, and it will not be either the GUI or
 the GL thread.
 
 Users should not start a <code>captureScreen3D</code> until previous
 <code>captureScreen3D</code> callback has returned. Starting a new
 <code>captureScreen3D</code> before the previous <code>captureScreen3D</code>
 callback returned may cause out of memory error.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>callback</code> - Callback function to process the capture result. It may not be
            <code>null</code>.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.6.8</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/GVRContext.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-files/index-1.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../org/gearvrf/GVRCameraRig.GVRCameraRigType.YawOnly.html" title="class in org.gearvrf"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../org/gearvrf/GVRCubemapTexture.html" title="class in org.gearvrf"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?org/gearvrf/GVRContext.html" target="_top">Frames</a></li>
<li><a href="GVRContext.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
